// Generated by CoffeeScript 1.11.1
(function() {
  var CND, FS, OS, PATH, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  PATH = require('path');

  FS = require('fs');

  OS = require('os');

  this._new_line_assembler = function(settings, handler) {
    var R, arity, collector, extra, flush, length, push, ref, ref1, ref2, send, splitter, type;
    switch (arity = arguments.length) {
      case 1:
        ref = [null, settings], settings = ref[0], handler = ref[1];
        break;
      case 2:
        null;
        break;
      default:
        throw new Error("expected 1 or 2 arguments, got " + arity);
    }
    collector = [];
    extra = (ref1 = settings != null ? settings['extra'] : void 0) != null ? ref1 : true;
    splitter = (ref2 = settings != null ? settings['splitter'] : void 0) != null ? ref2 : '\n';
    if (!(type = CND.isa_text(splitter))) {
      throw new Error("expected a text for splitter, got a " + type);
    }

    /* TAINT should accept multiple characters, characters beyond 0xffff, regexes */
    if ((length = splitter.length) !== 1) {
      throw new Error("expected single character for splitter, got " + length);
    }
    push = function(data) {
      collector.push(data);
      return null;
    };
    send = function(data) {
      return handler(null, data);
    };
    flush = function(chunk) {
      if (chunk != null) {
        push(chunk);
      }
      if (collector.length > 0) {
        send(collector.join(''));
        collector.length = 0;
      }
      return null;
    };
    R = function(chunk) {
      var last_idx, nl_idx, results, start_idx;
      if (chunk == null) {
        flush();
        if (extra) {
          handler(null, null);
        }
        return null;
      }
      start_idx = 0;
      last_idx = chunk.length - 1;
      if (last_idx < 0) {
        handler(null, '');
        return null;
      }
      results = [];
      while (true) {
        nl_idx = chunk.indexOf(splitter, start_idx);
        if (nl_idx < 0) {
          push(start_idx === 0 ? chunk : chunk.slice(start_idx));
          break;
        }
        if (nl_idx === 0) {
          flush();
        } else {
          flush(chunk.slice(start_idx, nl_idx));
        }
        if (nl_idx === last_idx) {
          break;
        }
        results.push(start_idx = nl_idx + 1);
      }
      return results;
    };
    return R;
  };


  /* thx to German Attanasio http://stackoverflow.com/a/28564000/256361 */


  /* TAINT copied from PipeDreams */

  this._isa_nodestream = function(x) {
    return x instanceof (require('stream')).Stream;
  };

  this._isa_readable_nodestream = function(x) {
    return (this._isa_nodestream(x)) && x.readable;
  };

  this._isa_writable_nodestream = function(x) {
    return (this._isa_nodestream(x)) && x.writable;
  };

  this._isa_readonly_nodestream = function(x) {
    return (this._isa_nodestream(x)) && x.readable && !x.writable;
  };

  this._isa_writeonly_nodestream = function(x) {
    return (this._isa_nodestream(x)) && x.writable && !x.readable;
  };

  this._isa_duplex_nodestream = function(x) {
    return (this._isa_nodestream(x)) && x.readable && x.writable;
  };

  this._type_of = function(x) {
    if (this._isa_nodestream(x)) {
      return 'nodestream';
    }
    return CND.type_of(x);
  };

  this.new_stream = function(path) {
    var R, input, self;
    self = this;
    R = {};
    R.transforms = [];

    /* TAINT strictly, no need to inline these methods; could be same for all instances, except @ binding */
    R.pipe = function(transform_info) {
      var arity, method, mode, transform, type;
      type = null;
      mode = null;
      arity = null;
      transform = null;
      switch (type = self._type_of(transform_info)) {
        case 'function':
          throw new Error("### currently not supported ###");
          break;
        case 'PIPESTREAMS/transform-info':
          type = 'function';
          method = transform_info.method, arity = transform_info.arity, mode = transform_info.mode;
          transform = method;
          break;
        case 'nodestream':
          transform = transform_info;
          break;
        default:
          throw new Error("expected a NodeJS stream, a PIPESTREAMS/transform-info or a function, got a " + type);
      }
      this.transforms.push({
        type: type,
        mode: mode,
        arity: arity,
        transform: transform
      });
      return this;
    };
    R.on = function() {
      var P;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return input.on.apply(input, P);
    };
    input = FS.createReadStream(path, {
      highWaterMark: 120,
      encoding: 'utf-8'
    });
    input.on('data', function(chunk) {
      var arity, handler, i, len, mode, next_collector, ref, ref1, results, this_collector, this_value, transform, transform_idx, type;
      this_collector = [chunk];
      next_collector = [];
      ref = R.transforms;
      results = [];
      for (transform_idx = i = 0, len = ref.length; i < len; transform_idx = ++i) {
        ref1 = ref[transform_idx], type = ref1.type, mode = ref1.mode, arity = ref1.arity, transform = ref1.transform;
        switch (type) {
          case 'function':

            /* TAINT only works with synchronous transforms */
            handler = (function(_this) {
              return function(next_value) {
                return next_collector.push(next_value);
              };
            })(this);
            while (this_collector.length > 0) {
              this_value = this_collector.shift();
              transform(this_value, handler);
            }
            this_collector = next_collector;
            results.push(next_collector = []);
            break;
          case 'nodestream':

            /* TAINT honor backpressure */
            results.push((function() {
              var results1;
              results1 = [];
              while (this_collector.length > 0) {
                this_value = this_collector.shift();
                results1.push(transform.write(this_value));
              }
              return results1;
            })());
            break;
          default:
            throw new Error("expected a NodeJS stream or a function, got a " + (CND.type_of(transform)));
        }
      }
      return results;
    });
    return R;
  };

  this.$ = this.remit = function(method) {
    var R, arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = method.length) !== 2) {
      throw new Error("### MEH ###");
    }
    R = {
      '~isa': 'PIPESTREAMS/transform-info',
      mode: 'sync',
      method: method,
      arity: arity
    };
    return R;
  };

  this.$async = this.remit_async = function(method) {
    var R, arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = method.length) !== 2) {
      throw new Error("### MEH ###");
    }
    R = {
      '~isa': 'PIPESTREAMS/transform-info',
      mode: 'async',
      method: method,
      arity: arity
    };
    return R;
  };

  this.$pass = function() {

    /* TAINT rewrite as observer transform (without the `send` argument) */
    return this.$(function(data, send) {
      return send(data);
    });
  };

  this.$show = function() {

    /* TAINT rewrite as observer transform (without the `send` argument) */
    var my_info;
    my_info = CND.get_logger('info', '*');
    return this.$(function(data, send) {
      send(data);
      my_info(rpr(data));
      return null;
    });
  };

  this.$split = function() {
    var assembler, main_send;
    main_send = null;
    assembler = this._new_line_assembler({
      extra: false,
      splitter: '\n'
    }, function(error, line) {
      if (error != null) {
        return main_send.error(error);
      }
      return main_send(line);
    });
    return this.$((function(_this) {
      return function(chunk, send) {
        main_send = send;
        assembler(chunk);
        return null;
      };
    })(this));
  };

  this.$as_line = function(stringify) {
    if (stringify == null) {
      stringify = JSON.stringify;
    }
    return this.$((function(_this) {
      return function(data, send) {
        send((CND.isa_text(data) ? data : stringify(data)) + '\n');
        return null;
      };
    })(this));
  };

}).call(this);

//# sourceMappingURL=main.js.map
