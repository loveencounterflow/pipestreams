// Generated by CoffeeScript 2.3.1
(function() {
  'use strict';
  var $pass_through, $pull_drain, $pull_split, $pull_utf8_decoder, $stringify, $take, $values, CND, CP, Event_emitter, FS, STPS, alert, badge, debug, echo, help, info, log, new_pushable, pluck, pull, pull_async_map, pull_cont, pull_many, pull_paramap, pull_through, return_id, rpr, urge, warn, whisper,
    splice = [].splice;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  // #...........................................................................................................
  // PATH                      = require 'path'
  // OS                        = require 'os'
  FS = require('fs');

  CP = require('child_process');

  //...........................................................................................................
  /* files, conversion from/to NodeJS push streams: */
  /* later
  new_file_source           = require 'pull-file'
  new_file_sink             = require 'pull-write-file'
  */
  STPS = require('stream-to-pull-stream');

  //...........................................................................................................
  /* stream creation: */
  new_pushable = require('pull-pushable');

  //...........................................................................................................
  /* transforms: */
  $pull_split = require('pull-split');

  // $pull_stringify           = require 'pull-stringify'
  $pull_utf8_decoder = require('pull-utf8-decoder');

  $pass_through = require('pull-stream/throughs/through');

  $pull_drain = require('pull-stream/sinks/drain');

  $take = require('pull-stream/throughs/take');

  $stringify = require('pull-stringify');

  $values = require('pull-stream/sources/values');

  pull = require('pull-stream');

  // map                       = pull.map.bind pull
  pull_through = require('pull-through');

  pull_async_map = require('pull-stream/throughs/async-map');

  pull_many = require('pull-many');

  pull_cont = require('pull-cont');

  pull_paramap = require('pull-paramap');

  // pull_infinite             = require 'pull-stream/sources/infinite'
  Event_emitter = require('eventemitter3');

  //...........................................................................................................
  return_id = function(x) {
    return x;
  };

  // { step, }                 = CND.suspend
  //-----------------------------------------------------------------------------------------------------------
  pluck = function(x, key, fallback) {
    var R;
    R = x[key];
    if (R === void 0) {
      R = fallback;
    }
    delete x[key];
    return R;
  };

  //===========================================================================================================
  // EVENTS AND EMITTERS
  //-----------------------------------------------------------------------------------------------------------
  this._new_event_emitter = function() {
    var R, _emit;
    R = new Event_emitter();
    _emit = R.emit.bind(R);
    //.........................................................................................................
    R.emit = function(event_name, ...P) {
      if (event_name !== '*') {
        _emit('*', event_name, ...P);
      }
      return _emit(event_name, ...P);
    };
    // #.........................................................................................................
    // R.on = ( name, P... ) ->
    //   # ### experimental: accept only 'namespaced' event names a la 'foo/bar' and known names
    //   # so as to prevent accidental usage of bogus event names like `end`, `close`, `finish` etc: ###
    //   # unless ( '/' in name ) or ( name is 'stop' )
    //   #   throw new Error "µ1763 unknown event name #{rpr name}"
    //   emitter.on name, P...
    //.........................................................................................................
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_event_collector = function(for_event_name, method) {
    var R, aggregator, arity, type;
    switch (arity = arguments.length) {
      case 0:
        null;
        break;
      case 2:
        if ((type = CND.type_of(for_event_name)) !== 'text') {
          throw new Error(`µ2528 expected a text, got a ${type}`);
        }
        if ((type = CND.type_of(method)) !== 'function') {
          throw new Error(`µ3293 expected a function, got a ${type}`);
        }
        break;
      default:
        throw new Error(`µ4058 expected 0 or 2 arguments, got ${arity}`);
    }
    //.........................................................................................................
    R = this._new_event_emitter();
    R._event_counts = {};
    R._source_count = 0;
    R._emitters = new WeakMap();
    //.........................................................................................................
    aggregator = function(event_name) {
      var event_count, ref;
      event_count = R._event_counts[event_name] = ((ref = R._event_counts[event_name]) != null ? ref : 0) + 1;
      if (event_count === R._source_count) {
        R.emit(event_name);
      }
      return null;
    };
    //.........................................................................................................
    R.add = function(emitter) {
      if ((type = CND.type_of(emitter.on)) !== 'function') {
        throw new Error(`µ4823 expected an event emitter with an \`on\` method, got a ${type}`);
      }
      if (R._emitters.has(emitter)) {
        throw new Error("µ5588 got duplicate emitter");
      }
      R._emitters.set(emitter, 1);
      R._source_count += +1;
      emitter.on('*', aggregator);
      return emitter;
    };
    if (method != null) {
      //.........................................................................................................
      R.on(for_event_name, method);
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._mixin_event_emitter = function(method) {
    var emitter;
    emitter = this._new_event_emitter();
    //.........................................................................................................
    method.on = function(event_name, ...P) {
      return emitter.on(event_name, ...P);
    };
    //.........................................................................................................
    method.emit = function(event_name, ...P) {
      return emitter.emit(event_name, ...P);
    };
    //.........................................................................................................
    return method;
  };

  
var prop = require('pull-stream/util/prop')

this._map_errors = function (mapper) {
  if(!mapper) return return_id
  mapper = prop(mapper)
  return function (read) {
    return function (abort, cb) {
      read(abort, function (end, data) {
        // try {
        data = !end ? mapper(data) : null
        // } catch (err) {
        //   return read(err, function () {
        //     return cb(err)
        //   })
        // }
        cb(end, data)
      })
    }
  }
}
  // original_map = require 'pull-stream/throughs/map'
  // @_map_errors = ( P... ) -> original_map P...
  /* This is the original `pull-stream/throughs/map` implementation with the `try`/`catch` clause removed so
  all errors are thrown. This, until we find out how to properly handle errors the pull-streams way. Note
  that `_map_errors` behaves exactly like `pull-stream/throughs/filter` which tells me this shouldn't be
  too wrong. Also observe that while any library may require all errors to be given to a callback or
  somesuch, no library can really enforce that because not all client code may be wrapped, so I think
  we're stuck with throwing errors anyway. */
;

  //===========================================================================================================
  // ISA METHODS
  //-----------------------------------------------------------------------------------------------------------
  /* thx to German Attanasio http://stackoverflow.com/a/28564000/256361 */
  this._isa_njs_stream = function(x) {
    return x instanceof (require('stream')).Stream;
  };

  this._isa_readable_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.readable;
  };

  this._isa_writable_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.writable;
  };

  this._isa_readonly_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.readable && !x.writable;
  };

  this._isa_writeonly_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.writable && !x.readable;
  };

  this._isa_duplex_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.readable && x.writable;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._nodejs_input_to_pull_source = function(...P) {
    return STPS.source(...P);
  };

  //-----------------------------------------------------------------------------------------------------------
  /* consider using https://github.com/dominictarr/pull-fs instead */
  this.new_file_source = function(...P) {
    return this._new_file_source_using_stps(...P);
  };

  this.new_file_sink = function(...P) {
    return this._new_file_sink_using_stps(...P);
  };

  this._new_file_source_using_stps = function(...P) {
    return STPS.source(FS.createReadStream(...P));
  };

  //-----------------------------------------------------------------------------------------------------------
  this._new_file_sink_using_stps = function(path_or_stream) {
    /* TAINT intermediate solution */
    var R, emitter, path, ref, stream;
    if (CND.isa_text(path_or_stream)) {
      path = path_or_stream;
      stream = FS.createWriteStream(path_or_stream);
    } else {
      path = (ref = path_or_stream.path) != null ? ref : '<UNKNOWN PATH>';
      if (!this._isa_njs_stream(path_or_stream)) {
        throw new Error(`µ6353 expected a path or a stream, got a ${CND.type_of(path_or_stream)}`);
      }
      if (!path_or_stream.writable) {
        throw new Error(`µ7118 expected a path or a stream, got a ${CND.type_of(path_or_stream)}`);
      }
      stream = path_or_stream;
    }
    R = STPS.sink(stream, (error) => {
      if (error != null) {
        throw error;
      }
    });
    emitter = this._new_event_emitter();
    R.on = function(name, ...P) {
      return emitter.on(name, ...P);
    };
    //.........................................................................................................
    stream.on('finish', function() {
      if ((!emitter.listeners('stop', true)) && (!emitter.listeners('*', true))) {
        warn(`stream to ${rpr(path)} finished without listener`);
      }
      return emitter.emit('stop');
    });
    //.........................................................................................................
    return R;
  };

  /* later (perhaps)
  #-----------------------------------------------------------------------------------------------------------
  @_new_file_source_using_pullfile  = ( P... ) -> new_file_source P...

  #-----------------------------------------------------------------------------------------------------------
  @_new_file_sink_using_pwf = ( path, options = null ) ->
  throw new Error "µ7883 not implemented"
   * TAINT errors with "DeprecationWarning: Calling an asynchronous function without callback is deprecated." (???)
  options ?= {}
  return new_file_sink path, options, ( error ) ->
    throw error if error?
    return null
   */
  //-----------------------------------------------------------------------------------------------------------
  /* TAINT refactor: `PS.new_source.from_path`, `PS.new_source.from_text`..., `PS.new_sink.as_text` (???) */
  this.new_text_source = function(text) {
    return $values([text]);
  };

  this.new_text_sink = function() {
    throw new Error("µ8648 not implemented");
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_value_source = function(values) {
    return $values(values);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.map_start = function(method) {
    var arity, is_first, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error(`µ9413 expected a function, got a ${type}`);
    }
    if ((arity = method.length) !== 0) {
      throw new Error(`µ10178 method arity ${arity} not implemented`);
    }
    is_first = true;
    return this._map_errors((data) => {
      if (is_first) {
        is_first = false;
        method();
      }
      return data;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.map_stop = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error(`µ10943 expected a function, got a ${type}`);
    }
    if ((arity = method.length) !== 0) {
      throw new Error(`µ11708 method arity ${arity} not implemented`);
    }
    return $pass_through(return_id, function(abort) {
      method();
      return abort;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.map_first = function(method) {
    var arity, is_first, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error(`µ12473 expected a function, got a ${type}`);
    }
    if ((arity = method.length) !== 1) {
      throw new Error(`µ13238 method arity ${arity} not implemented`);
    }
    is_first = true;
    return this._map_errors((data) => {
      if (is_first) {
        is_first = false;
        method(data);
      }
      return data;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.map_last = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error(`µ14003 expected a function, got a ${type}`);
    }
    if ((arity = method.length) !== 1) {
      throw new Error(`µ14768 method arity ${arity} not implemented`);
    }
    throw new Error('meh');
  };

  //-----------------------------------------------------------------------------------------------------------
  this.filter = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error(`µ15533 expected a function, got a ${type}`);
    }
    switch (arity = method.length) {
      case 1:
        null;
        break;
      default:
        throw new Error(`µ16298 method arity ${arity} not implemented`);
    }
    //.........................................................................................................
    return pull.filter(method);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.map = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error(`µ17063 expected a function, got a ${type}`);
    }
    switch (arity = method.length) {
      case 1:
        null;
        break;
      default:
        throw new Error(`µ17828 method arity ${arity} not implemented`);
    }
    //.........................................................................................................
    return this._map_errors(method);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$ = this.remit = function(hint, method) {
    var arity, client_arity, on_data, on_end, self, send, type;
    switch (arity = arguments.length) {
      case 1:
        method = hint;
        hint = null;
        break;
      case 2:
        if (hint !== 'null') {
          throw new Error(`µ18593 unknown hint ${rpr(hint)}`);
        }
        break;
      default:
        throw new Error(`µ19358 expected 1 or 2 arguments, got ${arity}`);
    }
    //.........................................................................................................
    switch (client_arity = method.length) {
      case 2:
        null;
        break;
      default:
        throw new Error(`µ20123 method arity ${client_arity} not implemented`);
    }
    if ((type = CND.type_of(method)) !== 'function') {
      //.........................................................................................................
      throw new Error(`µ20888 expected a function, got a ${type}`);
    }
    //.........................................................................................................
    self = null;
    send = (data) => {
      return self.queue(data);
    };
    on_end = null;
    //.........................................................................................................
    on_data = function(data) {
      self = this;
      method(data, send);
      self = null;
      return null;
    };
    //.........................................................................................................
    if (hint === 'null') {
      on_end = function() {
        self = this;
        method(null, send);
        self = null;
        /* somewhat hidden in the docs: *must* call `@queue null` to end stream: */
        this.queue(null);
        return null;
      };
    }
    //.........................................................................................................
    return pull_through(on_data, on_end);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._$async_map = pull_async_map;

  this._$paramap = pull_paramap;

  // #-----------------------------------------------------------------------------------------------------------
  // @$async = @remit_async = ( method ) ->
  //   throw new Error "µ21653 expected a function, got a #{type}" unless ( type = CND.type_of method ) is 'function'
  //   throw new Error "µ22418 ### MEH ###" unless ( arity = method.length ) is 2

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.$pass = function() {
    return this._map_errors((data) => {
      return data;
    });
  };

  //...........................................................................................................
  this.$as_line = function() {
    return this._map_errors((line) => {
      return line + '\n';
    });
  };

  this.$trim = function() {
    return this._map_errors((line) => {
      return line.trim();
    });
  };

  this.$split_fields = function() {
    return this._map_errors((line) => {
      return line.split(/\s*\t\s*/);
    });
  };

  this.$skip_empty = function() {
    return this.filter((line) => {
      return line.length > 0;
    });
  };

  //...........................................................................................................
  this.$push_to_list = function(collector) {
    return this._map_errors((data) => {
      collector.push(data);
      return data;
    });
  };

  this.$add_to_set = function(collector) {
    return this._map_errors((data) => {
      collector.add(data);
      return data;
    });
  };

  //...........................................................................................................
  this.$count = function() {
    throw new Error("µ23183 not implemented");
  };

  this.$take = $take;

  //-----------------------------------------------------------------------------------------------------------
  this.$drain = function(on_end = null) {
    var R;
    R = this._mixin_event_emitter($pull_drain(null, function() {
      return R.emit('stop');
    }));
    if (on_end != null) {
      R.on('stop', on_end);
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$watch = function(method) {
    return this._map_errors((data) => {
      method(data);
      return data;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT not sure how to call this / how to unify with the rest of the API */
  this._$watch_null = function(method) {
    var on_each, on_stop;
    on_each = function(data) {
      method(data);
      return null;
    };
    on_stop = function(abort) {
      method(null);
      return null;
    };
    return $pass_through(on_each, on_stop);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$name_fields = function(names) {
    var type;
    if ((type = CND.type_of(names)) !== 'list') {
      throw new Error(`µ23948 expected a list, got a ${type}`);
    }
    return this._map_errors((fields) => {
      var R, i, idx, len, name, value;
      if ((type = CND.type_of(fields)) !== 'list') {
        throw new Error(`µ24713 expected a list, got a ${type}`);
      }
      R = {};
      for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
        value = fields[idx];
        name = names[idx] != null ? names[idx] : names[idx] = `field_${idx}`;
        R[name] = value;
      }
      return R;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$trim_fields = function() {
    return this.$watch((fields) => {
      var field, i, idx, len;
      for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
        field = fields[idx];
        fields[idx] = field.trim();
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$split_tsv = function() {
    var R;
    R = [];
    R.push(this.$split());
    R.push(this.$trim());
    R.push(this.$skip_empty());
    R.push(this.filter(function(line) {
      return !line.startsWith('#');
    }));
    R.push(this.$split_fields());
    // R.push @$trim_fields()
    return this.pull(...R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.pull = function(...methods) {
    var i, idx, len, method, type;
    if (methods.length === 0) {
      return this.$pass();
    }
    for (idx = i = 0, len = methods.length; i < len; idx = ++i) {
      method = methods[idx];
      if ((type = CND.type_of(method)) === 'function') {
        continue;
      }
      throw new Error(`µ25478 expected a function, got a ${type} for argument # ${idx + 1}`);
    }
    return pull(...methods);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$split = function(settings) {
    var R, mapper, matcher, reverse, skip_last;
    if (settings != null) {
      throw new Error("µ26243 MEH");
    }
    R = [];
    matcher = null;
    mapper = null;
    reverse = false;
    skip_last = true;
    R.push($pull_utf8_decoder());
    R.push($pull_split(matcher, mapper, reverse, skip_last));
    return pull(...R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$join = function(joiner = null) {
    var collector, is_first, length, type;
    collector = [];
    length = 0;
    type = null;
    is_first = true;
    return this.$('null', function(data, send) {
      var this_type;
      if (data != null) {
        if (is_first) {
          is_first = false;
          type = CND.type_of(data);
          switch (type) {
            case 'text':
              if (joiner == null) {
                joiner = '';
              }
              break;
            case 'buffer':
              if (joiner != null) {
                throw new Error(`µ27008 joiner not supported for buffers, got ${rpr(joiner)}`);
              }
              break;
            default:
              throw new Error(`µ27773 expected a text or a buffer, got a ${type}`);
          }
        } else {
          if ((this_type = CND.type_of(data)) !== type) {
            throw new Error(`µ28538 expected a ${type}, got a ${this_type}`);
          }
        }
        length += data.length;
        collector.push(data);
      } else {
        if ((collector.length === 0) || (length === 0)) {
          return send('');
        }
        if (type === 'text') {
          return send(collector.join(''));
        }
        return send(Buffer.concat(collector, length));
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$pluck = function(settings) {
    var as, keys, ref;
    if (settings == null) {
      throw new Error(`µ29303 need settings 'keys', got ${rpr(settings)}`);
    }
    ({keys} = settings);
    if (keys == null) {
      throw new Error(`µ30068 need settings 'keys', got ${rpr(settings)}`);
    }
    if (CND.isa_text(keys)) {
      keys = keys.split(/,\s*|\s+/);
    }
    if (!(keys.length > 0)) {
      throw new Error(`µ30833 need settings 'keys', got ${rpr(settings)}`);
    }
    as = (ref = settings['as']) != null ? ref : 'object';
    if (as !== 'list' && as !== 'object' && as !== 'pod') {
      throw new Error(`µ31598 expected 'list', 'object' or 'pod', got ${rpr(as)}`);
    }
    if (as === 'list') {
      return this.map((data) => {
        var i, key, len, results;
        results = [];
        for (i = 0, len = keys.length; i < len; i++) {
          key = keys[i];
          results.push(data[key]);
        }
        return results;
      });
    }
    return this.map((data) => {
      var Z, i, key, len;
      Z = {};
      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        Z[key] = data[key];
      }
      return Z;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$gliding_window = function(width, method) {
    var push, section, send;
    if ((CND.type_of(width)) !== 'number') {
      throw new Error(`µ32363 expected a number, got a ${type}`);
    }
    section = [];
    send = null;
    //.........................................................................................................
    push = function(x) {
      var R;
      section.push(x);
      R = (function() {
        var results;
        results = [];
        while (section.length > width) {
          results.push(send(section.shift()));
        }
        return results;
      })();
      return null;
    };
    //.........................................................................................................
    return this.$('null', (new_data, send_) => {
      send = send_;
      if (new_data != null) {
        push(new_data);
        if (section.length >= width) {
          method(section);
        }
      } else {
        while (section.length > 0) {
          send(section.shift());
        }
        send(null);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$collect = function(settings) {
    var collector;
    if (settings != null) {
      throw new Error("µ33128 API changed");
    }
    collector = [];
    return this.$('null', (data, send) => {
      if (data != null) {
        collector.push(data);
      } else {
        send(collector);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$spread = function() {
    return this.$((collection, send) => {
      var element, i, len;
      for (i = 0, len = collection.length; i < len; i++) {
        element = collection[i];
        send(element);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$sort = function(settings) {
    /* https://github.com/mziccard/node-timsort */
    var $sort, TIMSORT, arity, direction, key, ref, ref1, ref2, sorter, type_of, validate_type;
    TIMSORT = require('timsort');
    direction = 'ascending';
    sorter = null;
    key = null;
    switch (arity = arguments.length) {
      case 0:
        null;
        break;
      case 1:
        direction = (ref = settings['direction']) != null ? ref : 'ascending';
        sorter = (ref1 = settings['sorter']) != null ? ref1 : null;
        key = (ref2 = settings['key']) != null ? ref2 : null;
        break;
      default:
        throw new Error(`µ33893 expected 0 or 1 arguments, got ${arity}`);
    }
    //.........................................................................................................
    if (direction !== 'ascending' && direction !== 'descending') {
      throw new Error(`µ34658 expected 'ascending' or 'descending' for direction, got ${rpr(direction)}`);
    }
    //.........................................................................................................
    if (sorter == null) {
      //.......................................................................................................
      type_of = (x) => {
        /* NOTE for the purposes of magnitude comparison, `Infinity` can be treated as a number: */
        var R;
        R = CND.type_of(x);
        if (R === 'infinity') {
          return 'number';
        } else {
          return R;
        }
      };
      //.......................................................................................................
      validate_type = (type_a, type_b, include_list = false) => {
        if (type_a !== type_b) {
          throw new Error(`µ35423 unable to compare a ${type_a} with a ${type_b}`);
        }
        if (include_list) {
          if (type_a !== 'number' && type_a !== 'date' && type_a !== 'text' && type_a !== 'list') {
            throw new Error(`µ36188 unable to compare values of type ${type_a}`);
          }
        } else {
          if (type_a !== 'number' && type_a !== 'date' && type_a !== 'text') {
            throw new Error(`µ36953 unable to compare values of type ${type_a}`);
          }
        }
        return null;
      };
      //.......................................................................................................
      if (key != null) {
        sorter = (a, b) => {
          a = a[key];
          b = b[key];
          validate_type(type_of(a), type_of(b), false);
          if ((direction === 'ascending' ? a > b : a < b)) {
            return +1;
          }
          if ((direction === 'ascending' ? a < b : a > b)) {
            return -1;
          }
          return 0;
        };
      } else {
        //.......................................................................................................
        sorter = (a, b) => {
          var type_a, type_b;
          validate_type((type_a = type_of(a)), (type_b = type_of(b)), true);
          if (type_a === 'list') {
            a = a[0];
            b = b[0];
            validate_type(type_of(a), type_of(b), false);
          }
          if ((direction === 'ascending' ? a > b : a < b)) {
            return +1;
          }
          if ((direction === 'ascending' ? a < b : a > b)) {
            return -1;
          }
          return 0;
        };
      }
    }
    //.........................................................................................................
    $sort = () => {
      var collector;
      collector = [];
      return this.$('null', (data, send) => {
        var i, len, x;
        if (data != null) {
          collector.push(data);
        } else {
          TIMSORT.sort(collector, sorter);
          for (i = 0, len = collector.length; i < len; i++) {
            x = collector[i];
            send(x);
          }
          collector.length = 0;
        }
        return null;
      });
    };
    //.........................................................................................................
    return $sort();
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$tee = function(stream) {
    /* **NB** that in contradistinction to `pull-tee`, you can only divert to a single by-stream with each
    call to `PS.$tee` */
    // R = if ( CND.isa_list stream_or_pipeline ) then ( pull stream_or_pipeline ) else stream_or_pipeline
    return (require('pull-tee'))(stream);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$show = function(settings) {
    var ref, ref1, serialize, title;
    title = (ref = settings != null ? settings['title'] : void 0) != null ? ref : '-->';
    serialize = (ref1 = settings != null ? settings['serialize'] : void 0) != null ? ref1 : JSON.stringify;
    return this.$watch((data) => {
      return info(title, serialize(data));
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$as_text = function(settings) {
    var ref, serialize;
    serialize = (ref = settings != null ? settings['serialize'] : void 0) != null ? ref : JSON.stringify;
    return this._map_errors((data) => {
      return serialize(data);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$stringify = function(settings) {
    return $stringify(settings);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$desaturate = function() {
    /* remove ANSI escape sequences */
    var pattern;
    pattern = /\x1b\[[0-9;]*[JKmsu]/g;
    return this.map((line) => {
      return line.replace(pattern, '');
    });
  };

  //===========================================================================================================
  // SPAWN
  //-----------------------------------------------------------------------------------------------------------
  this.spawn_collect = function(...P) {
    var $on_data, handler, pipeline, ref, source;
    ref = P, [...P] = ref, [handler] = splice.call(P, -1);
    //.........................................................................................................
    $on_data = () => {
      var command, stderr, stdout;
      command = null;
      stderr = [];
      stdout = [];
      return this.$watch((event) => {
        var key, value;
        [key, value] = event;
        switch (key) {
          case 'command':
            command = value;
            break;
          case 'stdout':
            stdout.push(value);
            break;
          case 'stderr':
            stderr.push(value);
            break;
          case 'exit':
            return handler(null, Object.assign({command, stdout, stderr}, value));
          default:
            throw new Error("µ37718 internal error 2201991");
        }
        return null;
      });
    };
    //.........................................................................................................
    source = this.spawn(...P);
    pipeline = [];
    //.........................................................................................................
    pipeline.push(source);
    pipeline.push($on_data());
    pipeline.push(this.$drain());
    //.........................................................................................................
    pull(...pipeline);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.spawn = function(...P) {
    return (this._spawn(...P))[1];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._spawn = function(command, settings) {
    var $ensure_event_order, arity, command_source, command_type, comments, confluence, cp, error_to_exit, event_buffer, event_pipeline, funnel, on_data, source, stderr, stderr_pipeline, stdout, stdout_is_binary, stdout_pipeline;
    //.........................................................................................................
    switch (arity = arguments.length) {
      case 1:
      case 2:
        null;
        break;
      default:
        throw new Error(`µ38483 expected 1 or 2 arguments, got ${arity}`);
    }
    //.........................................................................................................
    // throw new Error "µ39248 deprecated setting: error_to_exit" if ( pluck settings, 'error_to_exit',  null )?
    // stderr_target     = pluck settings, 'stderr', 'stderr'
    settings = Object.assign({
      shell: true
    }, settings);
    stdout_is_binary = pluck(settings, 'binary', false);
    comments = pluck(settings, 'comments', {});
    on_data = pluck(settings, 'on_data', null);
    error_to_exit = pluck(settings, 'error_to_exit', false);
    command_source = this.new_value_source([['command', command]]);
    //.........................................................................................................
    switch (command_type = CND.type_of(command)) {
      case 'text':
        cp = CP.spawn(command, settings);
        break;
      case 'list':
        if (!(command.length > 0)) {
          throw new Error(`µ40013 expected a list with at least one value, got ${rpr(command)}`);
        }
        cp = CP.spawn(command[0], command.slice(1), settings);
        break;
      default:
        throw new Error(`µ40778 expected a text or a list for command, got ${command_type}`);
    }
    //.........................................................................................................
    stdout = STPS.source(cp.stdout);
    stderr = STPS.source(cp.stderr);
    //.........................................................................................................
    stdout_pipeline = [];
    stderr_pipeline = [];
    funnel = [];
    event_pipeline = [];
    event_buffer = [];
    //.........................................................................................................
    stdout_pipeline.push(stdout);
    if (!stdout_is_binary) {
      stdout_pipeline.push(this.$split());
    }
    // stdout_pipeline.push @async_map ( data, handler ) -> defer -> handler null, data
    stdout_pipeline.push(this.map(function(line) {
      return ['stdout', line];
    }));
    //.........................................................................................................
    stderr_pipeline.push(stderr);
    stderr_pipeline.push(this.$split());
    // stderr_pipeline.push @$show title: '**44321**'
    // stderr_pipeline.push @async_map ( data, handler ) -> defer -> handler null, data
    stderr_pipeline.push(this.map(function(line) {
      return ['stderr', line];
    }));
    //.........................................................................................................
    /* Event handling: collect all events from child process */
    cp.on('disconnect', () => {
      return event_buffer.push(['disconnect', null]);
    });
    /* TAINT exit and error events should use same method to do post-processing */
    cp.on('error', (error) => {
      return event_buffer.push(['error', error != null ? error : null]);
    });
    cp.on('exit', (code, signal) => {
      var comment, ref, ref1, ref2, ref3;
      if ((signal != null) && (code == null)) {
        code = 128 + ((ref = this._spawn._signals_and_codes[signal]) != null ? ref : 0);
      }
      comment = (ref1 = (ref2 = comments[code]) != null ? ref2 : this._spawn._codes_and_comments[code]) != null ? ref1 : signal;
      if (comment == null) {
        comment = code === 0 ? 'ok' : (ref3 = comments['error']) != null ? ref3 : 'error';
      }
      return event_buffer.push(['exit', {code, signal, comment}]);
    });
    //.......................................................................................................
    /* The 'close' event should always come last, so we use that to trigger asynchronous sending of
    all events collected in the signal buffer. See https://github.com/dominictarr/pull-cont */
    event_pipeline.push(pull_cont((handler) => {
      return cp.on('close', () => {
        handler(null, this.new_value_source(event_buffer));
        return null;
      });
    }));
    //.........................................................................................................
    /* Since reading from a spawned process is inherently asynchronous, we cannot be sure all of the output
    from stdout and stderr has been sent down the pipeline before events from the child process arrive.
    Therefore, we have to buffer those events and send them on only when the confluence stream has indicated
    exhaustion: */
    $ensure_event_order = () => {
      var command_sent, cp_buffer, std_buffer;
      cp_buffer = [];
      std_buffer = [];
      command_sent = false;
      return this.$('null', (event, send) => {
        var category;
        if (event != null) {
          [category] = event;
          /* Events from stdout and stderr are buffered until the command event has been sent; after that,
          they are sent immediately: */
          if (category === 'stdout' || category === 'stderr') {
            // debug '10921>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>', command_sent, std_buffer
            // send [ 'stderr', '!!!!!!!!!!!!!!!', ]
            if (command_sent) {
              if (on_data != null) {
                return on_data(event);
              } else {
                return send(event);
              }
            }
            return std_buffer.push(event);
          }
          /* The command event is sent right away; any buffered stdout, stderr events are flushed: */
          if (category === 'command') {
            command_sent = true;
            send(event);
            while (std_buffer.length > 0) {
              if (on_data != null) {
                on_data(std_buffer.shift());
              } else {
                send(std_buffer.shift());
              }
            }
            return;
          }
          /* Keep everything else (i.e. events from child process) for later: */
          cp_buffer.push(event);
        } else {
          while (cp_buffer.length > 0) {
            /* Send all buffered CP events: */
            send(cp_buffer.shift());
          }
        }
        // if on_data? then on_data std_buffer.shift() else send std_buffer.shift()
        return null;
      });
    };
    //.........................................................................................................
    confluence = pull_many([pull(command_source), pull(...stdout_pipeline), pull(...stderr_pipeline), pull(...event_pipeline)]);
    //.........................................................................................................
    funnel.push(confluence);
    funnel.push($ensure_event_order());
    // funnel.push @$show title: '**21129**'
    //.........................................................................................................
    if (error_to_exit) {
      funnel.push((() => {
        var error;
        error = [];
        return this.$((event, send) => {
          var key, value;
          if (event != null) {
            [key, value] = event;
            switch (key) {
              case 'command':
              case 'stdout':
                return send(event);
              case 'stderr':
                return error.push(value.trimRight());
              case 'exit':
                value.error = error.join('\n');
                if (value.error.length === 0) {
                  value.error = null;
                }
                return send(event);
              default:
                throw new Error("µ41543 internal error 110918");
            }
          }
        });
      })());
    }
    //.........................................................................................................
    source = pull(...funnel);
    return [cp, source];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._spawn._signals_and_codes = {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 7,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 10,
    SIGSEGV: 11,
    SIGUSR2: 12,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGSTKFLT: 16,
    SIGCHLD: 17,
    SIGCONT: 18,
    SIGSTOP: 19,
    SIGTSTP: 20,
    SIGTTIN: 21,
    SIGTTOU: 22,
    SIGURG: 23,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 29,
    SIGPOLL: 29,
    SIGPWR: 30,
    SIGSYS: 31
  };

  //-----------------------------------------------------------------------------------------------------------
  this._spawn._codes_and_comments = {
    // 1:      'an error has occurred'
    126: 'permission denied',
    127: 'command not found'
  };

  //===========================================================================================================
  // SAMPLING / THINNING OUT
  //-----------------------------------------------------------------------------------------------------------
  this.$sample = function(p = 0.5, options) {
    var headers, is_first, ref, ref1, rnd, seed;
    //.........................................................................................................
    if (!((0 <= p && p <= 1))) {
      throw new Error(`µ42308 expected a number between 0 and 1, got ${rpr(p)}`);
    }
    if (p === 1) {
      //.........................................................................................................
      /* Handle trivial edge cases faster (hopefully): */
      return this.map((record) => {
        return record;
      });
    }
    if (p === 0) {
      return this.filter((record) => {
        return false;
      });
    }
    //.........................................................................................................
    headers = (ref = options != null ? options['headers'] : void 0) != null ? ref : false;
    seed = (ref1 = options != null ? options['seed'] : void 0) != null ? ref1 : null;
    is_first = headers;
    rnd = seed != null ? CND.get_rnd(seed) : Math.random;
    //.........................................................................................................
    return this.$((record, send) => {
      if (is_first) {
        is_first = false;
        return send(record);
      }
      if (rnd() < p) {
        return send(record);
      }
    });
  };

}).call(this);

//# sourceMappingURL=main.js.map
