// Generated by CoffeeScript 1.11.1
(function() {
  var CND, FS, OS, PATH, alert, badge, debug, echo, help, info, input, log, rpr, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  PATH = require('path');

  FS = require('fs');

  OS = require('os');

  this.new_line_assembler = function(settings, handler) {
    var R, arity, collector, extra, flush, length, push, ref, ref1, ref2, send, splitter, type;
    switch (arity = arguments.length) {
      case 1:
        ref = [null, settings], settings = ref[0], handler = ref[1];
        break;
      case 2:
        null;
        break;
      default:
        throw new Error("expected 1 or 2 arguments, got " + arity);
    }
    collector = [];
    extra = (ref1 = settings != null ? settings['extra'] : void 0) != null ? ref1 : true;
    splitter = (ref2 = settings != null ? settings['splitter'] : void 0) != null ? ref2 : '\n';
    if (!(type = CND.isa_text(splitter))) {
      throw new Error("expected a text for splitter, got a " + type);
    }

    /* TAINT should accept multiple characters, characters beyond 0xffff, regexes */
    if ((length = splitter.length) !== 1) {
      throw new Error("expected single character for splitter, got " + length);
    }
    push = function(data) {
      collector.push(data);
      return null;
    };
    send = function(data) {
      return handler(null, data);
    };
    flush = function(chunk) {
      if (chunk != null) {
        push(chunk);
      }
      if (collector.length > 0) {
        send(collector.join(''));
        collector.length = 0;
      }
      return null;
    };
    R = function(chunk) {
      var last_idx, nl_idx, results, start_idx;
      if (chunk == null) {
        flush();
        if (extra) {
          handler(null, null);
        }
        return null;
      }
      start_idx = 0;
      last_idx = chunk.length - 1;
      if (last_idx < 0) {
        handler(null, '');
        return null;
      }
      results = [];
      while (true) {
        nl_idx = chunk.indexOf(splitter, start_idx);
        if (nl_idx < 0) {
          push(start_idx === 0 ? chunk : chunk.slice(start_idx));
          break;
        }
        if (nl_idx === 0) {
          flush();
        } else {
          flush(chunk.slice(start_idx, nl_idx));
        }
        if (nl_idx === last_idx) {
          break;
        }
        results.push(start_idx = nl_idx + 1);
      }
      return results;
    };
    return R;
  };

  this.new_stream = function(path) {
    var R, input;
    R = {};
    R.transforms = [];
    R.pipe = function(transform) {
      this.transforms.push(transform);
      return this;
    };
    input = FS.createReadStream(path, {
      highWaterMark: 120,
      encoding: 'utf-8'
    });
    input.on('data', function(chunk) {
      var i, len, ref, results, this_value, transform, transform_idx;
      this_value = chunk;
      ref = R.transforms;
      results = [];
      for (transform_idx = i = 0, len = ref.length; i < len; transform_idx = ++i) {
        transform = ref[transform_idx];
        results.push(transform(this_value, (function(_this) {
          return function(next_value) {
            return this_value = next_value;
          };
        })(this)));
      }
      return results;
    });
    input.on('end', function() {
      return urge('input ended');
    });
    input.on('close', function() {
      return urge('input closed');
    });
    return R;
  };

  this.$ = this.remit = function(method) {
    if (method.length !== 2) {
      throw new Error("### MEH ###");
    }
    return method;
  };

  this.$show = function() {

    /* TAINT rewrite as observer transform (with the `send` argument) */
    var my_info;
    my_info = CND.get_logger('info', '*');
    return this.$(function(data, send) {
      send(data);
      my_info(rpr(data));
      return null;
    });
  };

  this.$split = function() {
    var assembler, main_send;
    main_send = null;
    assembler = this.new_line_assembler({
      extra: false,
      splitter: '\n'
    }, function(error, line) {
      if (error != null) {
        return main_send.error(error);
      }
      return main_send(line);
    });
    return this.$((function(_this) {
      return function(chunk, send) {
        main_send = send;
        assembler(chunk);
        return null;
      };
    })(this));
  };

  this["test line assembler"] = function(T, done) {
    var assembler, chunk, chunks, collector, i, len, text;
    text = "\"　2. 纯；专：专～。～心～意。\"\n!\"　3. 全；满：～生。～地水。\"\n\"　4. 相同：～样。颜色不～。\"\n\"　5. 另外!的：蟋蟀～名促织。!\"\n\"　6. 表示动作短暂，或是一次，或具试探性：算～算。试～试。\"!\n\"　7. 乃；竞：～至于此。\"";
    chunks = text.split('!');
    text = text.replace(/!/g, '');
    collector = [];
    assembler = this.new_line_assembler({
      extra: true,
      splitter: '\n'
    }, function(error, line) {
      if (error != null) {
        throw error;
      }
      if (line != null) {
        collector.push(line);
        return info(rpr(line));
      } else {
        return debug(CND.truth(CND.equals(text, collector.join('\n'))));
      }
    });
    for (i = 0, len = chunks.length; i < len; i++) {
      chunk = chunks[i];
      assembler(chunk);
    }
    return assembler(null);
  };

  input = this.new_stream(PATH.resolve(__dirname, '../test-data/guoxuedashi-excerpts-short.txt'));

  input.pipe(this.$split()).pipe(this.$show());

}).call(this);

//# sourceMappingURL=main.js.map
