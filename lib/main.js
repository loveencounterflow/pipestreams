// Generated by CoffeeScript 1.12.1
(function() {
  "use strict";
  var $pass_through, $split, $stringify, $utf8, CND, FS, STPS, alert, async_map, badge, debug, echo, help, info, log, map, new_file_sink, new_file_source, pull, return_id, rpr, through, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  FS = require('fs');

  new_file_source = require('pull-file');

  new_file_sink = require('pull-write-file');

  $split = require('pull-split');

  $stringify = require('pull-stringify');

  $utf8 = require('pull-utf8-decoder');

  pull = require('pull-stream');

  map = pull.map.bind(pull);


  /* NOTE these two are different: */

  $pass_through = require('pull-stream/throughs/through');

  through = require('pull-through');

  async_map = require('pull-stream/throughs/async-map');

  STPS = require('stream-to-pull-stream');

  return_id = function(x) {
    return x;
  };

  this.new_file_source = function() {
    var P;
    P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this._new_file_source_using_stpd.apply(this, P);
  };

  this.new_file_sink = function() {
    var P;
    P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this._new_file_sink_using_stps.apply(this, P);
  };

  this._new_file_source_using_pullfile = function() {
    var P;
    P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return new_file_source.apply(null, P);
  };

  this._new_file_source_using_stpd = function() {
    var P, path, stream;
    P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    path = P[0];
    stream = FS.createReadStream.apply(FS, P);
    return STPS.source(stream);
  };

  this._new_file_sink_using_stps = function() {
    var P, stream;
    P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    stream = FS.createWriteStream.apply(FS, P);
    return STPS.sink(stream);
  };

  this._new_file_sink_using_pwf = function(path, options) {
    if (options == null) {
      options = null;
    }
    throw new Error("not implemented");

    /* TAINT errors with "DeprecationWarning: Calling an asynchronous function without callback is
    deprecated." (???)
     */
    if (options == null) {
      options = {};
    }
    return new_file_sink(path, options, function(error) {
      if (error != null) {
        throw error;
      }
      return null;
    });
  };

  this.map_start = function(method) {
    var arity, is_first, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = method.length) !== 0) {
      throw new Error("method arity " + arity + " not implemented");
    }
    is_first = true;
    return this.map((function(_this) {
      return function(data) {
        if (is_first) {
          is_first = false;
          method();
        }
        return data;
      };
    })(this));
  };

  this.map_stop = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = method.length) !== 0) {
      throw new Error("method arity " + arity + " not implemented");
    }
    return $pass_through(return_id, function(abort) {
      method();
      return abort;
    });
  };

  this.map_first = function(method) {
    var arity, is_first, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = method.length) !== 1) {
      throw new Error("method arity " + arity + " not implemented");
    }
    is_first = true;
    return this.map((function(_this) {
      return function(data) {
        if (is_first) {
          is_first = false;
          method(data);
        }
        return data;
      };
    })(this));
  };

  this.map_last = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = method.length) !== 1) {
      throw new Error("method arity " + arity + " not implemented");
    }
    throw new Error('meh');
  };

  this.filter = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    switch (arity = method.length) {
      case 1:
        null;
        break;
      default:
        throw new Error("method arity " + arity + " not implemented");
    }
    return pull.filter(method);
  };

  this.map = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    switch (arity = method.length) {
      case 1:
        null;
        break;
      default:
        throw new Error("method arity " + arity + " not implemented");
    }
    return map(method);
  };

  this.$ = this.remit = function(method) {
    var R, arity, on_data, self, send, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    switch (arity = method.length) {
      case 2:
        null;
        break;
      default:
        throw new Error("method arity " + arity + " not implemented");
    }
    self = null;
    send = (function(_this) {
      return function(data) {
        return self.queue(data);
      };
    })(this);
    on_data = function(data) {
      self = this;
      return method(data, send);
    };
    R = through(on_data);
    return R;
  };

  this.$async = this.remit_async = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = method.length) !== 2) {
      throw new Error("### MEH ###");
    }
  };

}).call(this);

//# sourceMappingURL=main.js.map
