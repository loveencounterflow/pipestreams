// Generated by CoffeeScript 1.11.1
(function() {
  var CND, FS, OS, PATH, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  PATH = require('path');

  FS = require('fs');

  OS = require('os');

  this.new_line_assembler = function(settings, handler) {
    var R, arity, collector, extra, flush, length, push, ref, ref1, ref2, send, splitter, type;
    switch (arity = arguments.length) {
      case 1:
        ref = [null, settings], settings = ref[0], handler = ref[1];
        break;
      case 2:
        null;
        break;
      default:
        throw new Error("expected 1 or 2 arguments, got " + arity);
    }
    collector = [];
    extra = (ref1 = settings != null ? settings['extra'] : void 0) != null ? ref1 : true;
    splitter = (ref2 = settings != null ? settings['splitter'] : void 0) != null ? ref2 : '\n';
    if (!(type = CND.isa_text(splitter))) {
      throw new Error("expected a text for splitter, got a " + type);
    }

    /* TAINT should accept multiple characters, characters beyond 0xffff, regexes */
    if ((length = splitter.length) !== 1) {
      throw new Error("expected single character for splitter, got " + length);
    }
    push = function(data) {
      collector.push(data);
      return null;
    };
    send = function(data) {
      return handler(null, data);
    };
    flush = function(chunk) {
      if (chunk != null) {
        push(chunk);
      }
      if (collector.length > 0) {
        send(collector.join(''));
        collector.length = 0;
      }
      return null;
    };
    R = function(chunk) {
      var last_idx, nl_idx, results, start_idx;
      if (chunk == null) {
        flush();
        if (extra) {
          handler(null, null);
        }
        return null;
      }
      start_idx = 0;
      last_idx = chunk.length - 1;
      if (last_idx < 0) {
        handler(null, '');
        return null;
      }
      results = [];
      while (true) {
        nl_idx = chunk.indexOf(splitter, start_idx);
        if (nl_idx < 0) {
          push(start_idx === 0 ? chunk : chunk.slice(start_idx));
          break;
        }
        if (nl_idx === 0) {
          flush();
        } else {
          flush(chunk.slice(start_idx, nl_idx));
        }
        if (nl_idx === last_idx) {
          break;
        }
        results.push(start_idx = nl_idx + 1);
      }
      return results;
    };
    return R;
  };


  /* thx to German Attanasio http://stackoverflow.com/a/28564000/256361 */


  /* TAINT copied from PipeDreams */

  this._isa_nodestream = function(x) {
    return x instanceof (require('stream')).Stream;
  };

  this._isa_readable_nodestream = function(x) {
    return (this._isa_nodestream(x)) && x.readable;
  };

  this._isa_writable_nodestream = function(x) {
    return (this._isa_nodestream(x)) && x.writable;
  };

  this._isa_readonly_nodestream = function(x) {
    return (this._isa_nodestream(x)) && x.readable && !x.writable;
  };

  this._isa_writeonly_nodestream = function(x) {
    return (this._isa_nodestream(x)) && x.writable && !x.readable;
  };

  this._isa_duplex_nodestream = function(x) {
    return (this._isa_nodestream(x)) && x.readable && x.writable;
  };

  this.new_stream = function(path) {
    var R, input;
    R = {};
    R.transforms = [];
    R.pipe = function(transform) {
      var type;
      if (CND.isa_function(transform)) {
        type = 'function';
      } else if (this._isa_nodestream(transform)) {
        type = 'nodestream';
      } else {
        throw new Error("expected a NodeJS stream or a function, got a " + (CND.type_of(transform)));
      }
      this.transforms.push([type, transform]);
      return this;
    };
    input = FS.createReadStream(path, {
      highWaterMark: 120,
      encoding: 'utf-8'
    });
    input.on('data', function(chunk) {
      var i, len, ref, ref1, results, this_value, transform, transform_idx, type;
      this_value = chunk;
      ref = R.transforms;
      results = [];
      for (transform_idx = i = 0, len = ref.length; i < len; transform_idx = ++i) {
        ref1 = ref[transform_idx], type = ref1[0], transform = ref1[1];
        switch (type) {
          case 'function':
            results.push(transform(this_value, (function(_this) {
              return function(next_value) {
                return this_value = next_value;
              };
            })(this)));
            break;
          case 'nodestream':
            results.push(transform.write(this_value));
            break;
          default:
            throw new Error("expected a NodeJS stream or a function, got a " + (CND.type_of(transform)));
        }
      }
      return results;
    });
    input.on('end', function() {
      return urge('input ended');
    });
    input.on('close', function() {
      return urge('input closed');
    });
    return R;
  };

  this.$ = this.remit = function(method) {
    if (method.length !== 2) {
      throw new Error("### MEH ###");
    }
    return method;
  };

  this.$pass = function() {

    /* TAINT rewrite as observer transform (without the `send` argument) */
    return this.$(function(data, send) {
      return send(data);
    });
  };

  this.$show = function() {

    /* TAINT rewrite as observer transform (without the `send` argument) */
    var my_info;
    my_info = CND.get_logger('info', '*');
    return this.$(function(data, send) {
      send(data);
      my_info(rpr(data));
      return null;
    });
  };

  this.$split = function() {
    var assembler, main_send;
    main_send = null;
    assembler = this.new_line_assembler({
      extra: false,
      splitter: '\n'
    }, function(error, line) {
      if (error != null) {
        return main_send.error(error);
      }
      return main_send(line);
    });
    return this.$((function(_this) {
      return function(chunk, send) {
        main_send = send;
        assembler(chunk);
        return null;
      };
    })(this));
  };

  this.$as_line = function(stringify) {
    if (stringify == null) {
      stringify = JSON.stringify;
    }
    return this.$((function(_this) {
      return function(data, send) {
        send((CND.isa_text(data) ? data : stringify(data)) + '\n');
        return null;
      };
    })(this));
  };

}).call(this);

//# sourceMappingURL=main.js.map
