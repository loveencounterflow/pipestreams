// Generated by CoffeeScript 2.3.1
(function() {
  'use strict';
  var $paramap, $pass_through, $pull_drain, $values, CND, CP, FS, L, PATH, _map_errors, after, alert, assign, badge, copy, debug, defer, echo, every, glob, help, info, is_empty, jr, log, pull, pull_cont, pull_through, return_id, rpr, symbols, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  FS = require('fs');

  CP = require('child_process');

  glob = require('globby');

  //...........................................................................................................
  $pass_through = require('pull-stream/throughs/through');

  $pull_drain = require('pull-stream/sinks/drain');

  $values = require('pull-stream/sources/values');

  $paramap = require('pull-paramap');

  pull = require('pull-stream');

  pull_through = require('pull-through');

  pull_cont = require('pull-cont');

  _map_errors = require('./_map_errors');

  //...........................................................................................................
  after = function(dts, f) {
    return setTimeout(f, dts * 1000);
  };

  every = function(dts, f) {
    return setInterval(f, dts * 1000);
  };

  defer = setImmediate;

  return_id = function(x) {
    return x;
  };

  ({is_empty, copy, assign, jr} = CND);

  //...........................................................................................................
  symbols = {
    misfit: Symbol('misfit'),
    last: Symbol('last')
  };

  //===========================================================================================================
  // ISA METHODS
  //-----------------------------------------------------------------------------------------------------------
  /* thx to German Attanasio http://stackoverflow.com/a/28564000/256361 */
  this._isa_njs_stream = function(x) {
    return x instanceof (require('stream')).Stream;
  };

  this._isa_readable_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.readable;
  };

  this._isa_writable_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.writable;
  };

  this._isa_readonly_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.readable && !x.writable;
  };

  this._isa_writeonly_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.writable && !x.readable;
  };

  this._isa_duplex_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.readable && x.writable;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.new_value_source = function(values) {
    return $values(values);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_push_source = function() {
    /* Return a `pull-streams` `pushable`. Methods `push` and `end` will be bound to the instance
    so they can be freely passed around. */
    var R, end, new_pushable, send, source;
    new_pushable = require('pull-pushable'); 
    source = new_pushable();
    R = function(...P) {
      return source(...P);
    };
    //.........................................................................................................
    send = function(d) {
      if (d != null) {
        source.push(d);
      } else {
        debug('22022 pipstreams/new_push_source ended');
        this.end();
      }
      return null;
    };
    //.........................................................................................................
    end = function(...P) {
      // source.push null
      source.end(...P);
      return null;
    };
    //.........................................................................................................
    R.send = send.bind(R);
    R.end = end.bind(R);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_random_async_value_source = function(dts, values) {
    /* Given an optional delta time in seconds `dts` (which defaults to 0.1 seconds) and a list of values,
    return a source that will asynchronously produce values at irregular intervals that randomly oscillate
    around `dts`. */
    var R, arity, idx, last_idx, new_timeout, tick;
    switch (arity = arguments.length) {
      case 1:
        [dts, values] = [0.1, dts];
        break;
      case 2:
        null;
        break;
      default:
        throw new Error(`µ77749 expected 1 or 2 arguments, got ${arity}`);
    }
    //.........................................................................................................
    R = this.new_push_source();
    new_timeout = function() {
      return (Math.random() + 0.001) * dts;
    };
    //.........................................................................................................
    idx = 0;
    last_idx = values.length - 1;
    //.........................................................................................................
    if (!(CND.isa_number(last_idx))) {
      throw new Error(`µ89231 expected a list-like object, got a ${CND.type_of(values)}`);
    }
    //.........................................................................................................
    tick = function() {
      if (idx <= last_idx) {
        R.send(values[idx]);
        idx += +1;
        after(new_timeout(), tick);
      } else {
        R.send(null);
      }
      return null;
    };
    //.........................................................................................................
    after(new_timeout(), tick);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_generator_source = function(generator) {
    return function(end, handler) {
      var R;
      if (end) {
        return handler(end);
      }
      R = generator.next();
      if (R.done) {
        return handler(true);
      }
      return handler(null, R.value);
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$filter = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error(`µ15533 expected a function, got a ${type}`);
    }
    switch (arity = method.length) {
      case 1:
        null;
        break;
      default:
        throw new Error(`µ16298 method arity ${arity} not implemented`);
    }
    //.........................................................................................................
    return pull.filter(method);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$map = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error(`µ17063 expected a function, got a ${type}`);
    }
    switch (arity = method.length) {
      case 1:
        null;
        break;
      default:
        throw new Error(`µ17828 method arity ${arity} not implemented`);
    }
    //.........................................................................................................
    return _map_errors(method);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._get_remit_settings = function(hint, method) {
    var arity, defaults, settings;
    defaults = {
      first: symbols.misfit,
      last: symbols.misfit,
      between: symbols.misfit,
      after: symbols.misfit,
      before: symbols.misfit
    };
    settings = assign({}, defaults);
    switch (arity = arguments.length) {
      case 1:
        method = hint;
        hint = null;
        break;
      case 2:
        if (CND.isa_text(hint)) {
          throw new Error("µ30902 Deprecated: use `{last:null}` instead of `'null'`");
        } else {
          settings = assign(settings, hint);
        }
        break;
      default:
        throw new Error(`µ19358 expected 1 or 2 arguments, got ${arity}`);
    }
    settings._surround = (settings.first !== symbols.misfit) || (settings.last !== symbols.misfit) || (settings.between !== symbols.misfit) || (settings.after !== symbols.misfit) || (settings.before !== symbols.misfit);
    return {settings, method};
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$ = this.remit = function(...P) {
    var PS, client_arity, data_after, data_before, data_between, data_first, data_last, is_first, method, on_data, on_end, self, send, send_after, send_before, send_between, send_first, send_last, settings, type;
    /* NOTE we're transitioning from the experimental `hint` call convention to the more flexible and
    standard `settings` (which are here placed first, not last, b/c one frequently wants to write out a
    function body as last argument). For a limited time, `'null'` is accepted in place of a `settings` object;
    after that, `{ last: null }` should be used. */
    //.........................................................................................................
    ({settings, method} = this._get_remit_settings(...P));
    switch (client_arity = method.length) {
      case 2:
        null;
        break;
      default:
        throw new Error(`µ20123 method arity ${client_arity} not implemented`);
    }
    if ((type = CND.type_of(method)) !== 'function') {
      //.........................................................................................................
      throw new Error(`µ20888 expected a function, got a ${type}`);
    }
    //.........................................................................................................
    self = null;
    send = (data) => {
      return self.queue(data);
    };
    data_first = settings.first;
    data_before = settings.before;
    data_between = settings.between;
    data_after = settings.after;
    data_last = settings.last;
    send_first = data_first !== symbols.misfit;
    send_before = data_before !== symbols.misfit;
    send_between = data_between !== symbols.misfit;
    send_after = data_after !== symbols.misfit;
    send_last = data_last !== symbols.misfit;
    on_end = null;
    is_first = true;
    PS = this;
    //.........................................................................................................
    on_data = function(data) {
      self = this;
      if (is_first) {
        is_first = false;
        if (send_first) {
          method(data_first, send);
        }
      } else {
        if (send_between) {
          method(data_between, send);
        }
      }
      if (send_before) {
        method(data_before, send);
      }
      method(data, send);
      if (send_after) {
        method(data_after, send);
      }
      self = null;
      return null;
    };
    //.........................................................................................................
    if (send_last) {
      on_end = function() {
        self = this;
        method(data_last, send);
        self = null;
        /* somewhat hidden in the docs: *must* call `@queue null` to end stream: */
        // defer -> @queue null
        this.queue(null);
        return null;
      };
    }
    //.........................................................................................................
    return pull_through(on_data, on_end);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$async = function(...P) {
    var arity, call_count, has_ended, method, pipeline, ref, settings, type;
    /* TAINT currently all results from client method are buffered until `done` gets called; see whether
    it is possible to use `await` so that each result can be sent doen the pipeline w/out buffering */
    //.........................................................................................................
    /* NOTE we're transitioning from the experimental `hint` call convention to the more flexible and
    standard `settings` (which are here placed first, not last, b/c one frequently wants to write out a
    function body as last argument). For a limited time, `'null'` is accepted in place of a `settings` object;
    after that, `{ last: null }` (or using other value except `PS.symbols.misfit`) should be used. */
    //.........................................................................................................
    ({settings, method} = this._get_remit_settings(...P));
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error(`µ18187 expected a function, got a ${type}`);
    }
    if (!((1 <= (ref = (arity = arguments.length)) && ref <= 2))) {
      throw new Error(`µ18203 expected one or two arguments, got ${arity}`);
    }
    if ((arity = method.length) !== 3) {
      throw new Error(`µ18219 method arity ${arity} not implemented`);
    }
    //.........................................................................................................
    pipeline = [];
    call_count = 0;
    has_ended = false;
    if (settings._surround) {
      //.........................................................................................................
      pipeline.push(this.$surround(settings));
    }
    pipeline.push(this.$surround({
      last: symbols.last
    }));
    //.........................................................................................................
    pipeline.push($paramap((d, handler) => {
      var collector, done, send;
      collector = [];
      //.......................................................................................................
      send = (d) => {
        if (d === null) {
          return handler(true);
        }
        collector.unshift(d);
        return null;
      };
      //.......................................................................................................
      done = () => {
        call_count += -1;
        handler(null, collector);
        if (has_ended && call_count < 1) {
          handler(true);
        }
        return null;
      };
      //.......................................................................................................
      if (d === symbols.last) {
        has_ended = true;
        if (call_count < 1) {
          handler(true);
        }
      } else {
        call_count += +1;
        defer(function() {
          return method(d, send, done);
        });
      }
      return null;
    }));
    //.........................................................................................................
    pipeline.push(this.$defer());
    pipeline.push(this.$((d, send) => {
      var results;
      results = [];
      while (d.length > 0) {
        results.push(send(d.pop()));
      }
      return results;
    }));
    //.........................................................................................................
    return this.pull(...pipeline);
  };

  //-----------------------------------------------------------------------------------------------------------
  /* Given a `settings` object, add values to the stream as `$ settings, ( d, send ) -> send d` would do,
  e.g. `$surround { first: 'first!', between: 'to appear in-between two values', }`. */
  this.$surround = function(settings) {
    return this.$(settings, (d, send) => {
      return send(d);
    });
  };

  //===========================================================================================================
  // ASYNC TRANSFORMS
  //-----------------------------------------------------------------------------------------------------------
  this.$defer = function() {
    return $paramap(function(d, handler) {
      return defer(function() {
        return handler(null, d);
      });
    });
  };

  this.$delay = function(dts) {
    return $paramap(function(d, handler) {
      return after(dts, function() {
        return handler(null, d);
      });
    });
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.$pass = function() {
    return _map_errors((data) => {
      return data;
    });
  };

  this.$drain = function(on_end = null) {
    return $pull_drain(null, on_end);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$watch = function(method) {
    return _map_errors((data) => {
      method(data);
      return data;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.pull = function(...methods) {
    var i, idx, len, method, type;
    if (methods.length === 0) {
      return this.$pass();
    }
    for (idx = i = 0, len = methods.length; i < len; idx = ++i) {
      method = methods[idx];
      if ((type = CND.type_of(method)) === 'function') {
        continue;
      }
      if (CND.isa_pod(method)) {
        continue;
      }
      throw new /* allowing for `{ x.source, x.sink, }` duplex streams */Error(`µ25478 expected a function, got a ${type} for argument # ${idx + 1}`);
    }
    return pull(...methods);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$collect = function(settings) {
    var collector;
    if (settings != null) {
      throw new Error("µ33128 API changed");
    }
    collector = [];
    return this.$({
      last: null
    }, (data, send) => {
      if (data != null) {
        collector.push(data);
      } else {
        send(collector);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$spread = function() {
    return this.$((collection, send) => {
      var element, i, len;
      for (i = 0, len = collection.length; i < len; i++) {
        element = collection[i];
        send(element);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$show = function(settings) {
    var ref, ref1, serialize, title;
    title = (ref = settings != null ? settings['title'] : void 0) != null ? ref : '-->';
    serialize = (ref1 = settings != null ? settings['serialize'] : void 0) != null ? ref1 : JSON.stringify;
    return this.$watch((data) => {
      return info(title, serialize(data));
    });
  };

  //===========================================================================================================
  // SAMPLING / THINNING OUT
  //-----------------------------------------------------------------------------------------------------------
  this.$sample = function(p = 0.5, options) {
    var headers, is_first, ref, ref1, rnd, seed;
    //.........................................................................................................
    if (!((0 <= p && p <= 1))) {
      throw new Error(`µ42308 expected a number between 0 and 1, got ${rpr(p)}`);
    }
    if (p === 1) {
      //.........................................................................................................
      /* Handle trivial edge cases faster (hopefully): */
      return this.$map((record) => {
        return record;
      });
    }
    if (p === 0) {
      return this.$filter((record) => {
        return false;
      });
    }
    //.........................................................................................................
    headers = (ref = options != null ? options['headers'] : void 0) != null ? ref : false;
    seed = (ref1 = options != null ? options['seed'] : void 0) != null ? ref1 : null;
    is_first = headers;
    rnd = seed != null ? CND.get_rnd(seed) : Math.random;
    //.........................................................................................................
    return this.$((record, send) => {
      if (is_first) {
        is_first = false;
        return send(record);
      }
      if (rnd() < p) {
        return send(record);
      }
    });
  };

  //###########################################################################################################
  /* Gather methods from submodules, bind all methods */
  L = this;

  (function() {
    var i, key, len, module, path, paths, patterns, settings, value;
    patterns = ['*.js', '!main.js', '!_*'];
    settings = {
      cwd: PATH.join(__dirname),
      deep: false,
      absolute: true
    };
    paths = glob.sync(patterns, settings);
//.........................................................................................................
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];
      module = require(path);
      for (key in module) {
        value = module[key];
        if (L[key] != null) {
          // continue if key.startsWith '_'
          throw new Error(`duplicate key ${rpr(key)}`);
        }
        L[key] = value;
      }
    }
//.........................................................................................................
    for (key in L) {
      value = L[key];
      if (!CND.isa_function(value)) {
        continue;
      }
      L[key] = value.bind(L);
    }
    //.........................................................................................................
    return null;
  })();

}).call(this);

//# sourceMappingURL=main.js.map
