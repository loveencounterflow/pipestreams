// Generated by CoffeeScript 2.3.1
(function() {
  'use strict';
  var $paramap, $pass_through, $pull_drain, $values, CND, CP, FS, L, PATH, _map_errors, _new_push_source, after, alert, assign, badge, copy, debug, defer, echo, glob, help, info, is_empty, jr, log, pull, pull_cont, pull_through, return_id, rpr, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  FS = require('fs');

  CP = require('child_process');

  glob = require('globby');

  //...........................................................................................................
  _new_push_source = require('pull-pushable');

  $pass_through = require('pull-stream/throughs/through');

  $pull_drain = require('pull-stream/sinks/drain');

  $values = require('pull-stream/sources/values');

  $paramap = require('pull-paramap');

  pull = require('pull-stream');

  pull_through = require('pull-through');

  pull_cont = require('pull-cont');

  _map_errors = require('./_map_errors');

  //...........................................................................................................
  after = function(dts, f) {
    return setTimeout(f, dts * 1000);
  };

  defer = setImmediate;

  return_id = function(x) {
    return x;
  };

  ({is_empty, copy, assign, jr} = CND);

  //===========================================================================================================
  // ISA METHODS
  //-----------------------------------------------------------------------------------------------------------
  /* thx to German Attanasio http://stackoverflow.com/a/28564000/256361 */
  this._isa_njs_stream = function(x) {
    return x instanceof (require('stream')).Stream;
  };

  this._isa_readable_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.readable;
  };

  this._isa_writable_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.writable;
  };

  this._isa_readonly_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.readable && !x.writable;
  };

  this._isa_writeonly_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.writable && !x.readable;
  };

  this._isa_duplex_njs_stream = function(x) {
    return (this._isa_njs_stream(x)) && x.readable && x.writable;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.new_value_source = function(values) {
    return $values(values);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_push_source = function() {
    /* Return a `pull-streams` `pushable`. Methods `push` and `end` will be bound to the instance
    so they can be freely passed around. */
    var R;
    R = _new_push_source();
    R.push = R.push.bind(R);
    R.end = R.end.bind(R);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_generator_source = function(generator) {
    return function(end, handler) {
      var R;
      if (end) {
        return handler(end);
      }
      R = generator.next();
      if (R.done) {
        return handler(true);
      }
      return handler(null, R.value);
    };
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @map_start = ( method ) ->
  //   throw new Error "µ9413 expected a function, got a #{type}" unless ( type = CND.type_of method ) is 'function'
  //   throw new Error "µ10178 method arity #{arity} not implemented" unless ( arity = method.length ) is 0
  //   is_first = yes
  //   return _map_errors ( data ) =>
  //     if is_first
  //       is_first = no
  //       method()
  //     return data

  // #-----------------------------------------------------------------------------------------------------------
  // @map_stop = ( method ) ->
  //   throw new Error "µ10943 expected a function, got a #{type}" unless ( type = CND.type_of method ) is 'function'
  //   throw new Error "µ11708 method arity #{arity} not implemented" unless ( arity = method.length ) is 0
  //   return $pass_through return_id, ( abort ) ->
  //     method()
  //     return abort

  // #-----------------------------------------------------------------------------------------------------------
  // @map_first = ( method ) ->
  //   throw new Error "µ12473 expected a function, got a #{type}" unless ( type = CND.type_of method ) is 'function'
  //   throw new Error "µ13238 method arity #{arity} not implemented" unless ( arity = method.length ) is 1
  //   is_first = yes
  //   return _map_errors ( data ) =>
  //     if is_first
  //       is_first = no
  //       method data
  //     return data

  // #-----------------------------------------------------------------------------------------------------------
  // @map_last = ( method ) ->
  //   throw new Error "µ14003 expected a function, got a #{type}" unless ( type = CND.type_of method ) is 'function'
  //   throw new Error "µ14768 method arity #{arity} not implemented" unless ( arity = method.length ) is 1
  //   throw new Error 'meh'

  //-----------------------------------------------------------------------------------------------------------
  this.$filter = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error(`µ15533 expected a function, got a ${type}`);
    }
    switch (arity = method.length) {
      case 1:
        null;
        break;
      default:
        throw new Error(`µ16298 method arity ${arity} not implemented`);
    }
    //.........................................................................................................
    return pull.filter(method);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$map = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error(`µ17063 expected a function, got a ${type}`);
    }
    switch (arity = method.length) {
      case 1:
        null;
        break;
      default:
        throw new Error(`µ17828 method arity ${arity} not implemented`);
    }
    //.........................................................................................................
    return _map_errors(method);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$ = this.remit = function(hint, method) {
    var arity, client_arity, on_data, on_end, self, send, type;
    switch (arity = arguments.length) {
      case 1:
        method = hint;
        hint = null;
        break;
      case 2:
        if (hint !== 'null') {
          throw new Error(`µ18593 unknown hint ${rpr(hint)}`);
        }
        break;
      default:
        throw new Error(`µ19358 expected 1 or 2 arguments, got ${arity}`);
    }
    //.........................................................................................................
    switch (client_arity = method.length) {
      case 2:
        null;
        break;
      default:
        throw new Error(`µ20123 method arity ${client_arity} not implemented`);
    }
    if ((type = CND.type_of(method)) !== 'function') {
      //.........................................................................................................
      throw new Error(`µ20888 expected a function, got a ${type}`);
    }
    //.........................................................................................................
    self = null;
    send = (data) => {
      return self.queue(data);
    };
    on_end = null;
    //.........................................................................................................
    on_data = function(data) {
      self = this;
      method(data, send);
      self = null;
      return null;
    };
    //.........................................................................................................
    if (hint === 'null') {
      on_end = function() {
        self = this;
        method(null, send);
        self = null;
        /* somewhat hidden in the docs: *must* call `@queue null` to end stream: */
        this.queue(null);
        return null;
      };
    }
    //.........................................................................................................
    return pull_through(on_data, on_end);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$async = function(method) {
    var arity, pipeline, type;
    if ((type = CND.type_of(method)) !== 'function') {
      /* TAINT signature should be ( hint, method ) */
      /* TAINT currently all results from client method are buffered until `done` gets called; see whether
      it is possible to use `await` so that each result can be sent doen the pipeline w/out buffering */
      throw new Error(`µ18187 expected a function, got a ${type}`);
    }
    if ((arity = arguments.length) !== 1) {
      throw new Error(`µ18203 expected one argument, got ${arity}`);
    }
    if ((arity = method.length) !== 3) {
      throw new Error(`µ18219 method arity ${arity} not implemented`);
    }
    pipeline = [];
    //.........................................................................................................
    pipeline.push($paramap((d, handler) => {
      var collector, done, prv_send, send;
      collector = [];
      prv_send = null;
      //.......................................................................................................
      send = (d) => {
        if (d === null) {
          return handler(true);
        }
        collector.unshift(d);
        return null;
      };
      //.......................................................................................................
      done = () => {
        handler(null, collector);
        return null;
      };
      //.......................................................................................................
      method(d, send, done);
      return null;
    }));
    //.........................................................................................................
    pipeline.push(this.$((d, send) => {
      var results;
      results = [];
      while (d.length > 0) {
        results.push(send(d.pop()));
      }
      return results;
    }));
    //.........................................................................................................
    return this.pull(...pipeline);
  };

  //===========================================================================================================
  // ASYNC TRANSFORMS
  //-----------------------------------------------------------------------------------------------------------
  this.$defer = function() {
    return $paramap(function(d, handler) {
      return defer(function() {
        return handler(null, d);
      });
    });
  };

  this.$delay = function(dts) {
    return $paramap(function(d, handler) {
      return after(dts, function() {
        return handler(null, d);
      });
    });
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.$pass = function() {
    return _map_errors((data) => {
      return data;
    });
  };

  this.$drain = function(on_end = null) {
    return $pull_drain(null, on_end);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$watch = function(method) {
    return _map_errors((data) => {
      method(data);
      return data;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.pull = function(...methods) {
    var i, idx, len, method, type;
    if (methods.length === 0) {
      return this.$pass();
    }
    for (idx = i = 0, len = methods.length; i < len; idx = ++i) {
      method = methods[idx];
      if ((type = CND.type_of(method)) === 'function') {
        continue;
      }
      throw new Error(`µ25478 expected a function, got a ${type} for argument # ${idx + 1}`);
    }
    return pull(...methods);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$gliding_window = function(width, method) {
    var push, section, send;
    if ((CND.type_of(width)) !== 'number') {
      throw new Error(`µ32363 expected a number, got a ${type}`);
    }
    section = [];
    send = null;
    //.........................................................................................................
    push = function(x) {
      var R;
      section.push(x);
      R = (function() {
        var results;
        results = [];
        while (section.length > width) {
          results.push(send(section.shift()));
        }
        return results;
      })();
      return null;
    };
    //.........................................................................................................
    return this.$('null', (new_data, send_) => {
      send = send_;
      if (new_data != null) {
        push(new_data);
        if (section.length >= width) {
          method(section);
        }
      } else {
        while (section.length > 0) {
          send(section.shift());
        }
        send(null);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$collect = function(settings) {
    var collector;
    if (settings != null) {
      throw new Error("µ33128 API changed");
    }
    collector = [];
    return this.$('null', (data, send) => {
      if (data != null) {
        collector.push(data);
      } else {
        send(collector);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$spread = function() {
    return this.$((collection, send) => {
      var element, i, len;
      for (i = 0, len = collection.length; i < len; i++) {
        element = collection[i];
        send(element);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$tee = function(stream) {
    /* **NB** that in contradistinction to `pull-tee`, you can only divert to a single by-stream with each
    call to `PS.$tee` */
    // R = if ( CND.isa_list stream_or_pipeline ) then ( pull stream_or_pipeline ) else stream_or_pipeline
    return (require('pull-tee'))(stream);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$show = function(settings) {
    var ref, ref1, serialize, title;
    title = (ref = settings != null ? settings['title'] : void 0) != null ? ref : '-->';
    serialize = (ref1 = settings != null ? settings['serialize'] : void 0) != null ? ref1 : JSON.stringify;
    return this.$watch((data) => {
      return info(title, serialize(data));
    });
  };

  //===========================================================================================================
  // SAMPLING / THINNING OUT
  //-----------------------------------------------------------------------------------------------------------
  this.$sample = function(p = 0.5, options) {
    var headers, is_first, ref, ref1, rnd, seed;
    //.........................................................................................................
    if (!((0 <= p && p <= 1))) {
      throw new Error(`µ42308 expected a number between 0 and 1, got ${rpr(p)}`);
    }
    if (p === 1) {
      //.........................................................................................................
      /* Handle trivial edge cases faster (hopefully): */
      return this.$map((record) => {
        return record;
      });
    }
    if (p === 0) {
      return this.$filter((record) => {
        return false;
      });
    }
    //.........................................................................................................
    headers = (ref = options != null ? options['headers'] : void 0) != null ? ref : false;
    seed = (ref1 = options != null ? options['seed'] : void 0) != null ? ref1 : null;
    is_first = headers;
    rnd = seed != null ? CND.get_rnd(seed) : Math.random;
    //.........................................................................................................
    return this.$((record, send) => {
      if (is_first) {
        is_first = false;
        return send(record);
      }
      if (rnd() < p) {
        return send(record);
      }
    });
  };

  //###########################################################################################################
  /* Gather methods from submodules, bind all methods */
  L = this;

  (function() {
    var i, key, len, module, path, paths, patterns, settings, value;
    patterns = ['*.js', '!main.js', '!_*'];
    settings = {
      cwd: PATH.join(__dirname),
      deep: false,
      absolute: true
    };
    paths = glob.sync(patterns, settings);
//.........................................................................................................
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];
      module = require(path);
      for (key in module) {
        value = module[key];
        if (key.startsWith('_')) {
          continue;
        }
        if (L[key] != null) {
          throw new Error(`duplicate key ${rpr(key)}`);
        }
        L[key] = value;
      }
    }
//.........................................................................................................
    for (key in L) {
      value = L[key];
      if (!CND.isa_function(value)) {
        continue;
      }
      L[key] = value.bind(L);
    }
    //.........................................................................................................
    return null;
  })();

}).call(this);

//# sourceMappingURL=main.js.map
