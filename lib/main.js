// Generated by CoffeeScript 1.12.2
(function() {
  'use strict';
  var $pass_through, $pull_drain, $pull_split, $pull_utf8_decoder, $stringify, $take, CND, CP, FS, STPS, alert, badge, debug, echo, help, info, log, map, new_pushable, pull, pull_async_map, pull_through, return_id, rpr, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  FS = require('fs');

  CP = require('child_process');


  /* files, conversion from/to NodeJS push streams: */


  /* later
  new_file_source           = require 'pull-file'
  new_file_sink             = require 'pull-write-file'
   */

  STPS = require('stream-to-pull-stream');


  /* stream creation: */

  new_pushable = require('pull-pushable');


  /* transforms: */

  $pull_split = require('pull-split');

  $pull_utf8_decoder = require('pull-utf8-decoder');

  $pass_through = require('pull-stream/throughs/through');

  $pull_drain = require('pull-stream/sinks/drain');

  $take = require('pull-stream/throughs/take');

  $stringify = require('pull-stringify');

  pull = require('pull-stream');

  map = pull.map.bind(pull);

  pull_through = require('pull-through');

  pull_async_map = require('pull-stream/throughs/async-map');

  return_id = function(x) {
    return x;
  };


  /* This is the original `pull-stream/throughs/map` implementation with the `try`/`catch` clause removed so
  all errors are thrown. This, until we find out how to properly handle errors the pull-streams way. Note
  that `_map_errors` behaves exactly like `pull-stream/throughs/filter` which tells me this shouldn't be
  too wrong. Also observe that while any library may require all errors to be given to a callback or
  somesuch, no library can really enforce that because not all client code may be wrapped, so I think
  we're stuck with throwing errors anyway.
   */

  
var prop = require('pull-stream/util/prop')

this._map_errors = function (mapper) {
  if(!mapper) return return_id
  mapper = prop(mapper)
  return function (read) {
    return function (abort, cb) {
      read(abort, function (end, data) {
        // try {
        data = !end ? mapper(data) : null
        // } catch (err) {
        //   return read(err, function () {
        //     return cb(err)
        //   })
        // }
        cb(end, data)
      })
    }
  }
}
;


  /* thx to German Attanasio http://stackoverflow.com/a/28564000/256361 */

  this._isa_njs_stream = function(x) {
    return x instanceof (require('stream')).Stream;
  };

  this._isa_readable_njs_stream = function(x) {
    return (this._isa_njs_njs_stream(x)) && x.readable;
  };

  this._isa_writable_njs_stream = function(x) {
    return (this._isa_njs_njs_stream(x)) && x.writable;
  };

  this._isa_readonly_njs_stream = function(x) {
    return (this._isa_njs_njs_stream(x)) && x.readable && !x.writable;
  };

  this._isa_writeonly_njs_stream = function(x) {
    return (this._isa_njs_njs_stream(x)) && x.writable && !x.readable;
  };

  this._isa_duplex_njs_stream = function(x) {
    return (this._isa_njs_njs_stream(x)) && x.readable && x.writable;
  };

  this.new_file_source = function() {
    var P;
    P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this._new_file_source_using_stps.apply(this, P);
  };

  this.new_file_sink = function() {
    var P;
    P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this._new_file_sink_using_stps.apply(this, P);
  };

  this._new_file_source_using_stps = function() {
    var P;
    P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return STPS.source(FS.createReadStream.apply(FS, P));
  };

  this._new_file_sink_using_stps = function(path_or_stream) {
    var R, stream;
    if (CND.isa_text(path_or_stream)) {
      stream = FS.createWriteStream(path_or_stream);
    } else {
      if (!this._isa_njs_stream(path_or_stream)) {
        throw new Error("expected a path or a stream, got a " + (CND.type_of(path_or_stream)));
      }
      if (!path_or_stream.writable) {
        throw new Error("expected a path or a stream, got a " + (CND.type_of(path_or_stream)));
      }
      stream = path_or_stream;
    }

    /* TAINT intermediate solution */
    R = STPS.sink(stream, (function(_this) {
      return function(error) {
        if (error != null) {
          throw error;
        }
      };
    })(this));
    R.on = function() {
      var P;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return stream.on.apply(stream, P);
    };
    return R;
  };


  /* later (perhaps)
  #-----------------------------------------------------------------------------------------------------------
  @_new_file_source_using_pullfile  = ( P... ) -> new_file_source P...
  
  #-----------------------------------------------------------------------------------------------------------
  @_new_file_sink_using_pwf = ( path, options = null ) ->
    throw new Error "not implemented"
     * TAINT errors with "DeprecationWarning: Calling an asynchronous function without callback is deprecated." (???)
    options ?= {}
    return new_file_sink path, options, ( error ) ->
      throw error if error?
      return null
   */

  this.map_start = function(method) {
    var arity, is_first, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = method.length) !== 0) {
      throw new Error("method arity " + arity + " not implemented");
    }
    is_first = true;
    return this._map_errors((function(_this) {
      return function(data) {
        if (is_first) {
          is_first = false;
          method();
        }
        return data;
      };
    })(this));
  };

  this.map_stop = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = method.length) !== 0) {
      throw new Error("method arity " + arity + " not implemented");
    }
    return $pass_through(return_id, function(abort) {
      method();
      return abort;
    });
  };

  this.map_first = function(method) {
    var arity, is_first, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = method.length) !== 1) {
      throw new Error("method arity " + arity + " not implemented");
    }
    is_first = true;
    return this._map_errors((function(_this) {
      return function(data) {
        if (is_first) {
          is_first = false;
          method(data);
        }
        return data;
      };
    })(this));
  };

  this.map_last = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    if ((arity = method.length) !== 1) {
      throw new Error("method arity " + arity + " not implemented");
    }
    throw new Error('meh');
  };

  this.filter = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    switch (arity = method.length) {
      case 1:
        null;
        break;
      default:
        throw new Error("method arity " + arity + " not implemented");
    }
    return pull.filter(method);
  };

  this.map = function(method) {
    var arity, type;
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    switch (arity = method.length) {
      case 1:
        null;
        break;
      default:
        throw new Error("method arity " + arity + " not implemented");
    }
    return map(method);
  };

  this.$ = this.remit = function(hint, method) {
    var arity, client_arity, on_data, on_end, self, send, type;
    switch (arity = arguments.length) {
      case 1:
        method = hint;
        hint = null;
        break;
      case 2:
        if (hint !== 'null') {
          throw new Error("unknown hint " + (rpr(hint)));
        }
        break;
      default:
        throw new Error("expected 1 or 2 arguments, got " + arity);
    }
    switch (client_arity = method.length) {
      case 2:
        null;
        break;
      default:
        throw new Error("method arity " + client_arity + " not implemented");
    }
    if ((type = CND.type_of(method)) !== 'function') {
      throw new Error("expected a function, got a " + type);
    }
    self = null;
    send = (function(_this) {
      return function(data) {
        return self.queue(data);
      };
    })(this);
    on_end = null;
    on_data = function(data) {
      self = this;
      method(data, send);
      self = null;
      return null;
    };
    if (hint === 'null') {
      on_end = function() {
        self = this;
        method(null, send);
        self = null;

        /* somewhat hidden in the docs: *must* call `@queue null` to end stream: */
        this.queue(null);
        return null;
      };
    }
    return pull_through(on_data, on_end);
  };

  this.async_map = pull_async_map;

  this.$pass = function() {
    return this._map_errors((function(_this) {
      return function(data) {
        return data;
      };
    })(this));
  };

  this.$as_line = function() {
    return this._map_errors((function(_this) {
      return function(line) {
        return line + '\n';
      };
    })(this));
  };

  this.$trim = function() {
    return this._map_errors((function(_this) {
      return function(line) {
        return line.trim();
      };
    })(this));
  };

  this.$split_fields = function() {
    return this._map_errors((function(_this) {
      return function(line) {
        return line.split(/\s*\t\s*/);
      };
    })(this));
  };

  this.$skip_empty = function() {
    return this.filter((function(_this) {
      return function(line) {
        return line.length > 0;
      };
    })(this));
  };

  this.$push_to_list = function(collector) {
    return this._map_errors((function(_this) {
      return function(data) {
        collector.push(data);
        return data;
      };
    })(this));
  };

  this.$add_to_set = function(collector) {
    return this._map_errors((function(_this) {
      return function(data) {
        collector.add(data);
        return data;
      };
    })(this));
  };

  this.$count = function() {
    throw new Error("not implemented");
  };

  this.$take = $take;

  this.$drain = function(on_end) {
    if (on_end == null) {
      on_end = null;
    }
    return $pull_drain(null, on_end);
  };

  this.$watch = function(method) {
    return this._map_errors((function(_this) {
      return function(data) {
        method(data);
        return data;
      };
    })(this));
  };


  /* TAINT not sure how to call this / how to unify with the rest of the API */

  this._$watch_null = function(method) {
    var on_each, on_stop;
    on_each = function(data) {
      method(data);
      return null;
    };
    on_stop = function(abort) {
      method(null);
      return null;
    };
    return $pass_through(on_each, on_stop);
  };

  this.$name_fields = function(names) {
    var type;
    if ((type = CND.type_of(names)) !== 'list') {
      throw new Error("expected a list, got a " + type);
    }
    return this._map_errors((function(_this) {
      return function(fields) {
        var R, i, idx, len, name, value;
        if ((type = CND.type_of(fields)) !== 'list') {
          throw new Error("expected a list, got a " + type);
        }
        R = {};
        for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
          value = fields[idx];
          name = names[idx] != null ? names[idx] : names[idx] = "field_" + idx;
          R[name] = value;
        }
        return R;
      };
    })(this));
  };

  this.$trim_fields = function() {
    return this.$watch((function(_this) {
      return function(fields) {
        var field, i, idx, len;
        for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
          field = fields[idx];
          fields[idx] = field.trim();
        }
        return null;
      };
    })(this));
  };

  this.$split_tsv = function() {
    var R;
    R = [];
    R.push(this.$split());
    R.push(this.$trim());
    R.push(this.$skip_empty());
    R.push(this.filter(function(line) {
      return !line.startsWith('#');
    }));
    R.push(this.$split_fields());
    return this.pull.apply(this, R);
  };

  this.pull = function() {
    var i, idx, len, method, methods, type;
    methods = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    for (idx = i = 0, len = methods.length; i < len; idx = ++i) {
      method = methods[idx];
      if ((type = CND.type_of(method)) === 'function') {
        continue;
      }
      throw new Error("expected a function, got a " + type + " for argument # " + (idx + 1));
    }
    return pull.apply(null, methods);
  };

  this.$split = function(settings) {
    var R, mapper, matcher, reverse, skip_last;
    if (settings != null) {
      throw new Error("MEH");
    }
    R = [];
    matcher = null;
    mapper = null;
    reverse = false;
    skip_last = true;
    R.push($pull_utf8_decoder());
    R.push($pull_split(matcher, mapper, reverse, skip_last));
    return pull.apply(null, R);
  };

  this.$pluck = function(settings) {
    var as, keys, ref;
    if (settings == null) {
      throw new Error("need settings 'keys', got " + (rpr(settings)));
    }
    keys = settings.keys;
    if (keys == null) {
      throw new Error("need settings 'keys', got " + (rpr(settings)));
    }
    if (CND.isa_text(keys)) {
      keys = keys.split(/,\s*|\s+/);
    }
    if (!(keys.length > 0)) {
      throw new Error("need settings 'keys', got " + (rpr(settings)));
    }
    as = (ref = settings['as']) != null ? ref : 'object';
    if (as !== 'list' && as !== 'object' && as !== 'pod') {
      throw new Error("expected 'list', 'object' or 'pod', got " + (rpr(as)));
    }
    if (as === 'list') {
      return this.map((function(_this) {
        return function(data) {
          var i, key, len, results;
          results = [];
          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            results.push(data[key]);
          }
          return results;
        };
      })(this));
    }
    return this.map((function(_this) {
      return function(data) {
        var Z, i, key, len;
        Z = {};
        for (i = 0, len = keys.length; i < len; i++) {
          key = keys[i];
          Z[key] = data[key];
        }
        return Z;
      };
    })(this));
  };

  this.$collect = function(settings) {

    /* When `settings[ 'collector' ]` is given, use `collector.push data` to push data into that
    list and do send data on; when `settings[ 'collector' ]` is not given, create a new list,
    push all data items into it, and send on the collector once the stream has finished.
     */
    var collector, send_all;
    if ((collector = settings != null ? settings['collector'] : void 0) != null) {
      send_all = true;
    } else {
      send_all = false;
      collector = [];
    }
    return this.$('null', (function(_this) {
      return function(data, send) {
        if (data != null) {
          collector.push(data);
          if (send_all) {
            send(data);
          }
        } else {
          if (!send_all) {
            send(collector);
          }
        }
        return null;
      };
    })(this));
  };

  this.$sort = function(settings) {

    /* https://github.com/mziccard/node-timsort */
    var $sort, TIMSORT, arity, direction, key, ref, ref1, ref2, sorter, type_of, validate_type;
    TIMSORT = require('timsort');
    direction = 'ascending';
    sorter = null;
    key = null;
    switch (arity = arguments.length) {
      case 0:
        null;
        break;
      case 1:
        direction = (ref = settings['direction']) != null ? ref : 'ascending';
        sorter = (ref1 = settings['sorter']) != null ? ref1 : null;
        key = (ref2 = settings['key']) != null ? ref2 : null;
        break;
      default:
        throw new Error("expected 0 or 1 arguments, got " + arity);
    }
    if (direction !== 'ascending' && direction !== 'descending') {
      throw new Error("expected 'ascending' or 'descending' for direction, got " + (rpr(direction)));
    }
    if (sorter == null) {
      type_of = (function(_this) {
        return function(x) {

          /* NOTE for the purposes of magnitude comparison, `Infinity` can be treated as a number: */
          var R;
          R = CND.type_of(x);
          if (R === 'infinity') {
            return 'number';
          } else {
            return R;
          }
        };
      })(this);
      validate_type = (function(_this) {
        return function(type_a, type_b, include_list) {
          if (include_list == null) {
            include_list = false;
          }
          if (type_a !== type_b) {
            throw new Error("unable to compare a " + type_a + " with a " + type_b);
          }
          if (include_list) {
            if (type_a !== 'number' && type_a !== 'date' && type_a !== 'text' && type_a !== 'list') {
              throw new Error("unable to compare values of type " + type_a);
            }
          } else {
            if (type_a !== 'number' && type_a !== 'date' && type_a !== 'text') {
              throw new Error("unable to compare values of type " + type_a);
            }
          }
          return null;
        };
      })(this);
      if (key != null) {
        sorter = (function(_this) {
          return function(a, b) {
            a = a[key];
            b = b[key];
            validate_type(type_of(a), type_of(b), false);
            if ((direction === 'ascending' ? a > b : a < b)) {
              return +1;
            }
            if ((direction === 'ascending' ? a < b : a > b)) {
              return -1;
            }
            return 0;
          };
        })(this);
      } else {
        sorter = (function(_this) {
          return function(a, b) {
            var type_a, type_b;
            validate_type((type_a = type_of(a)), (type_b = type_of(b)), true);
            if (type_a === 'list') {
              a = a[0];
              b = b[0];
              validate_type(type_of(a), type_of(b), false);
            }
            if ((direction === 'ascending' ? a > b : a < b)) {
              return +1;
            }
            if ((direction === 'ascending' ? a < b : a > b)) {
              return -1;
            }
            return 0;
          };
        })(this);
      }
    }
    $sort = (function(_this) {
      return function() {
        var collector;
        collector = [];
        return _this.$('null', function(data, send) {
          var i, len, x;
          if (data != null) {
            collector.push(data);
          } else {
            TIMSORT.sort(collector, sorter);
            for (i = 0, len = collector.length; i < len; i++) {
              x = collector[i];
              send(x);
            }
            collector.length = 0;
          }
          return null;
        });
      };
    })(this);
    return $sort();
  };

  this.$tee = function(stream) {

    /* **NB** that in contradistinction to `pull-tee`, you can only divert to a single by-stream with each
    call to `PS.$tee`
     */
    return (require('pull-tee'))(stream);
  };

  this.$show = function(settings) {
    var ref, ref1, serialize, title;
    title = (ref = settings != null ? settings['title'] : void 0) != null ? ref : '-->';
    serialize = (ref1 = settings != null ? settings['serialize'] : void 0) != null ? ref1 : JSON.stringify;
    return this.$watch((function(_this) {
      return function(data) {
        return info(title, serialize(data));
      };
    })(this));
  };

  this.$as_text = function(settings) {
    var ref, serialize;
    serialize = (ref = settings != null ? settings['serialize'] : void 0) != null ? ref : JSON.stringify;
    return this._map_errors((function(_this) {
      return function(data) {
        return serialize(data);
      };
    })(this));
  };

  this.$stringify = function(settings) {
    return $stringify(settings);
  };

  this.$desaturate = function() {

    /* remove ANSI escape sequences */
    var pattern;
    pattern = /\x1b\[[0-9;]*[JKmsu]/g;
    return this.map((function(_this) {
      return function(line) {
        return line.replace(pattern, '');
      };
    })(this));
  };

  this.spawn = function(command, settings, handler) {

    /* `spawn` accepts a `command` (as a string) and a `handler`. It will execute the command in a child
    process (using  `child_process command, { shell: yes, }`).
    
    `spawn` expects the output to be UTF-8-encoded text, but this may become configurable in the future to
    acommodate for non-textual outputs. Also, it may become possible to directly plug into the subprocess's
    `stdout` and `stderr` streams; for now, the callback is the only way to handle command output.
     */

    /* TAINT must also consider exit code other than zero */

    /* TAINT consider case where there is output on both channels */
    var arity, cp, ref, stderr, stderr_has_ended, stderr_lines, stderr_message, stderr_pipeline, stdout, stdout_has_ended, stdout_lines, stdout_message, stdout_pipeline, tap;
    switch (arity = arguments.length) {
      case 2:
        handler = settings;
        settings = null;
        break;
      case 3:
        null;
        break;
      default:
        throw new Error("expected 2 or 3 arguments, got " + arity);
    }
    tap = (ref = settings != null ? settings['tap'] : void 0) != null ? ref : null;
    cp = CP.spawn(command, {
      shell: true
    });
    stdout = STPS.source(cp.stdout);
    stdout_has_ended = false;
    stdout_lines = [];
    stdout_message = null;
    stdout_pipeline = [];
    stderr = STPS.source(cp.stderr);
    stderr_has_ended = false;
    stderr_lines = [];
    stderr_message = null;
    stderr_pipeline = [];
    stdout_pipeline.push(stdout);
    stdout_pipeline.push(this.$split());
    if (tap != null) {
      stdout_pipeline.push(this.async_map(function(line, handler) {

        /* By deferring passing on each line both in this and the tapping stream we create an opportunity
        for the tapping stream to run concurrently; without this, all lines would be buffered until the
        main stream has finished:
         */
        return setImmediate(function() {

          /* TAINT use a 1-element list, callback, only conclude when list empty */
          tap.push(line);
          return handler(null, line);
        });
      }));
    }
    stdout_pipeline.push(this.$show({
      title: '***'
    }));
    stdout_pipeline.push(this.$push_to_list(stdout_lines));
    stdout_pipeline.push(this.$drain(null, function() {
      stdout_has_ended = true;
      if (stderr_message != null) {
        return handler(stderr_message);
      }
      if (stdout_lines.length > 0) {
        stdout_message = stdout_lines.join('\n');
      }
      if (stderr_has_ended) {
        handler(null, stdout_message);
      }
      return null;
    }));
    pull.apply(null, stdout_pipeline);
    stderr_pipeline.push(stderr);
    stdout_pipeline.push(this.$split());
    stderr_pipeline.push(this.$push_to_list(stderr_lines));
    stderr_pipeline.push(this.$drain(null, function() {
      stderr_has_ended = true;
      if (stderr_lines.length > 0) {
        stderr_message = stderr_lines.join('\n');
        if (stdout_has_ended) {
          return handler(stderr_message);
        }
      }
      if (stdout_has_ended) {
        handler(null, stdout_message);
      }
      return null;
    }));
    pull.apply(null, stderr_pipeline);
    return null;
  };

}).call(this);

//# sourceMappingURL=main.js.map
