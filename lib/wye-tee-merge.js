// Generated by CoffeeScript 2.3.1
(function() {
  'use strict';
  var CND, badge, debug, defer/* https://github.com/nichoth/pull-mux */, jr, mux, rpr;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS/WYE-TEE-MERGE';

  // log                       = CND.get_logger 'plain',     badge
  // info                      = CND.get_logger 'info',      badge
  // whisper                   = CND.get_logger 'whisper',   badge
  // alert                     = CND.get_logger 'alert',     badge
  debug = CND.get_logger('debug', badge);

  // warn                      = CND.get_logger 'warn',      badge
  // help                      = CND.get_logger 'help',      badge
  // urge                      = CND.get_logger 'urge',      badge
  // echo                      = CND.echo.bind CND
  ({jr} = CND);

  mux = require('pull-mux');

  defer = setImmediate;

  //-----------------------------------------------------------------------------------------------------------
  this.$tee = function(stream) {
    /* **NB** that in contradistinction to `pull-tee`, you can only divert to a single by-stream with each
    call to `PS.$tee` */
    // R = if ( CND.isa_list stream_or_pipeline ) then ( pull stream_or_pipeline ) else stream_or_pipeline
    return (require('pull-tee'))(stream);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$merge = function(...sources) {
    var $_demux, $_mux, pipeline;
    //.........................................................................................................
    $_mux = (...sources) => {
      var R, i, idx, len, source;
      R = {};
      for (idx = i = 0, len = sources.length; i < len; idx = ++i) {
        source = sources[idx];
        R[idx] = source;
      }
      return mux(R);
    };
    //.........................................................................................................
    $_demux = () => {
      return this.$map(function([k, v]) {
        return v;
      });
    };
    //.........................................................................................................
    pipeline = [];
    pipeline.push($_mux(...sources));
    pipeline.push($_demux());
    return this.pull(...pipeline);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$wye = function(bysource) {
    var R, buffer, bystream, bystream_ended, bystream_started, done, flush, last_sym_1, last_sym_2, mainstream, pop, send, stack;
    bystream_started = false;
    bystream_ended = false;
    send = null;
    done = null;
    buffer = [];
    stack = (x) => {
      return buffer.unshift(x);
    };
    pop = () => {
      if (buffer.length > 0) {
        return send(buffer.pop());
      }
    };
    flush = () => {
      var results;
      results = [];
      while (buffer.length > 0) {
        results.push(send(buffer.pop()));
      }
      return results;
    };
    last_sym_1 = Symbol('last');
    last_sym_2 = Symbol('last');
    //.........................................................................................................
    bystream = [];
    bystream.push(bysource);
    bystream.push(this.$async({
      last: last_sym_1
    }, (d, _send, _done) => {
      if (d !== last_sym_1) {
        /* When `done` is defined, mainstream has ended, but `done` has not been called, meaning we can
        send directly (but avoid calling `done` yet); otherwise, we buffer the data: */
        if (done != null) {
          send(d);
        } else {
          stack(d);
        }
      } else {
        bystream_ended = true;
        if (done != null) {
          flush();
          done();
        }
      }
      _done();
      return null;
    }));
    bystream.push(this.$drain());
    //.........................................................................................................
    mainstream = [];
    mainstream.push(this.$async({
      last: last_sym_2
    }, (d, _send, _done) => {
      send = _send;
      done = _done;
      //.......................................................................................................
      if (!bystream_started) {
        bystream_started = true;
        this.pull(...bystream);
      }
      //.......................................................................................................
      if (d !== last_sym_2) {
        /* In case there's mainstream data, flush out any bystream data, send d, call `done` and
        un-define it: */
        // flush()
        send(d);
        pop();
        done();
        done = null;
      } else {
        /* In case mainstream data is `null`, mainstream has terminated. If bystream has been terminated
        as well, call `done` and un-define it: */
        flush();
        if (bystream_ended) {
          defer(function() {
            return send(null);
          });
          done();
          done = null;
        }
      }
      //.......................................................................................................
      return null;
    }));
    //.........................................................................................................
    R = this.pull(...mainstream);
    return R;
  };

}).call(this);

//# sourceMappingURL=wye-tee-merge.js.map
