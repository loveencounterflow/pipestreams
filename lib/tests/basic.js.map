{
  "version": 3,
  "file": "basic.js",
  "sourceRoot": "../..",
  "sources": [
    "src/tests/basic.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'PIPESTREAMS/TESTS/BASIC'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\nPATH                      = require 'path'\nFS                        = require 'fs'\nOS                        = require 'os'\nTAP                       = require 'tap'\n#...........................................................................................................\nPS                        = require '../..'\n{ $, $async, }            = PS\n#...........................................................................................................\npull                      = require 'pull-stream'\n$take                     = require 'pull-stream/throughs/take'\n$values                   = require 'pull-stream/sources/values'\n$pull_drain               = require 'pull-stream/sinks/drain'\npull_through              = require 'pull-through'\n\n# #-----------------------------------------------------------------------------------------------------------\n# TAP.test \"test line assembler\", ( T ) ->\n#   text = \"\"\"\n#   \"　2. 纯；专：专～。～心～意。\"\n#   !\"　3. 全；满：～生。～地水。\"\n#   \"　4. 相同：～样。颜色不～。\"\n#   \"　5. 另外!的：蟋蟀～名促织。!\"\n#   \"　6. 表示动作短暂，或是一次，或具试探性：算～算。试～试。\"!\n#   \"　7. 乃；竞：～至于此。\"\n#   \"\"\"\n#   # text = \"abc\\ndefg\\nhijk\"\n#   chunks    = text.split '!'\n#   text      = text.replace /!/g, ''\n#   collector = []\n#   assembler = PS._new_line_assembler { extra: true, splitter: '\\n', }, ( error, line ) ->\n#     throw error if error?\n#     if line?\n#       collector.push line\n#       info rpr line\n#     else\n#       # urge rpr text\n#       # help rpr collector.join '\\n'\n#       # debug collector\n#       if CND.equals text, collector.join '\\n'\n#         T.pass \"texts are equal\"\n#       T.end()\n#   for chunk in chunks\n#     assembler chunk\n#   assembler null\n\n# #-----------------------------------------------------------------------------------------------------------\n# TAP.test \"test throughput (1)\", ( T ) ->\n#   # input   = @new_stream PATH.resolve __dirname, '../test-data/guoxuedashi-excerpts-short.txt'\n#   input   = PS.new_stream PATH.resolve __dirname, '../../test-data/Unicode-NamesList-tiny.txt'\n#   output  = FS.createWriteStream '/tmp/output.txt'\n#   lines   = []\n#   input\n#     .pipe PS.$split()\n#     # .pipe PS.$show()\n#     .pipe PS.$pass()\n#     .pipe PS.$as_line()\n#     .pipe $ ( line, send ) ->\n#       lines.push line\n#       send line\n#     .pipe output\n#   ### TAINT use PipeStreams method ###\n#   input.on 'end', -> output.end()\n#   output.on 'close', ->\n#     # if CND.equals lines.join '\\n'\n#     T.pass \"assuming equality\"\n#     T.end()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# TAP.test \"test throughput (2)\", ( T ) ->\n#   # input   = @new_stream PATH.resolve __dirname, '../test-data/guoxuedashi-excerpts-short.txt'\n#   input   = PS.new_stream PATH.resolve __dirname, '../../test-data/Unicode-NamesList-tiny.txt'\n#   output  = FS.createWriteStream '/tmp/output.txt'\n#   lines   = []\n#   p       = input\n#   p       = p.pipe PS.$split()\n#   # p       = p.pipe PS.$show()\n#   p       = p.pipe PS.$pass()\n#   p       = p.pipe PS.$as_line()\n#   p       = p.pipe $ ( line, send ) ->\n#       lines.push line\n#       send line\n#   p       = p.pipe output\n#   ### TAINT use PipeStreams method ###\n#   input.on 'end', -> output.end()\n#   output.on 'close', ->\n#     # if CND.equals lines.join '\\n'\n#     # debug '12001', lines\n#     T.pass \"assuming equality\"\n#     T.end()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# TAP.test \"read with pipestreams\", ( T ) ->\n#   matcher       = [\n#     '01 ; charset=UTF-8',\n#     '02 @@@\\tThe Unicode Standard 9.0.0',\n#     '03 @@@+\\tU90M160615.lst',\n#     '04 \\tUnicode 9.0.0 final names list.',\n#     '05 \\tThis file is semi-automatically derived from UnicodeData.txt and',\n#     '06 \\ta set of manually created annotations using a script to select',\n#     '07 \\tor suppress information from the data file. The rules used',\n#     '08 \\tfor this process are aimed at readability for the human reader,',\n#     '09 \\tat the expense of some details; therefore, this file should not',\n#     '10 \\tbe parsed for machine-readable information.',\n#     '11 @+\\t\\t© 2016 Unicode®, Inc.',\n#     '12 \\tFor terms of use, see http://www.unicode.org/terms_of_use.html',\n#     '13 @@\\t0000\\tC0 Controls and Basic Latin (Basic Latin)\\t007F',\n#     '14 @@+'\n#     ]\n#   # input_path    = '../../test-data/Unicode-NamesList-tiny.txt'\n#   input_path    = '/home/flow/io/basic-stream-benchmarks/test-data/Unicode-NamesList-tiny.txt'\n#   # output_path   = '/dev/null'\n#   output_path   = '/tmp/output.txt'\n#   input         = PS.new_stream input_path\n#   output        = FS.createWriteStream output_path\n#   collector     = []\n#   S             = {}\n#   S.item_count  = 0\n#   S.byte_count  = 0\n#   p             = input\n#   p             = p.pipe $ ( data, send ) -> whisper '20078-1', rpr data; send data\n#   p             = p.pipe PS.$split()\n#   p             = p.pipe $ ( data, send ) -> help '20078-1', rpr data; send data\n#   #.........................................................................................................\n#   p             = p.pipe PS.$ ( line, send ) ->\n#     S.item_count += +1\n#     S.byte_count += line.length\n#     debug '22001-0', rpr line\n#     collector.push line\n#     send line\n#   #.........................................................................................................\n#   p             = p.pipe $ ( data, send ) -> urge '20078-2', rpr data; send data\n#   p             = p.pipe PS.$as_line()\n#   p             = p.pipe output\n#   #.........................................................................................................\n#   ### TAINT use PipeStreams method ###\n#   output.on 'close', ->\n#     # debug '88862', S\n#     # debug '88862', collector\n#     if CND.equals collector, matcher\n#       T.pass \"collector equals matcher\"\n#     T.end()\n#   #.........................................................................................................\n#   ### TAINT should be done by PipeStreams ###\n#   input.on 'end', ->\n#     output.end()\n#   #.........................................................................................................\n#   return null\n\n\n# #-----------------------------------------------------------------------------------------------------------\n# TAP.test \"remit without end detection\", ( T ) ->\n#   pipeline = []\n#   pipeline.push $values Array.from 'abcdef'\n#   pipeline.push $ ( data, send ) ->\n#     send data\n#     send '*' + data + '*'\n#   pipeline.push PS.$show()\n#   pipeline.push $pull_drain()\n#   PS.pull pipeline...\n#   T.pass \"ok\"\n#   T.end()\n\n#-----------------------------------------------------------------------------------------------------------\nTAP.test \"remit with end detection\", ( T ) ->\n  pipeline = []\n  pipeline.push $values Array.from 'abcdef'\n  # pipeline.push pull_through ( ( data ) -> urge data ), ( -> urge 'ok'; @queue null )\n  # pipeline.push pull_through ( ( data ) -> urge data ), null\n  pipeline.push $ 'null', ( data, send ) ->\n    if data?\n      send data\n      send '*' + data + '*'\n    else\n      send 'ok'\n  pipeline.push PS.$show()\n  pipeline.push $pull_drain()\n  PS.pull pipeline...\n  T.pass \"ok\"\n  T.end()\n\n#-----------------------------------------------------------------------------------------------------------\nTAP.test \"wrap FS object for sink\", ( T ) ->\n  output_path = '/tmp/pipestreams-test-output.txt'\n  output_file = FS.createWriteStream output_path\n  sink        = PS.new_file_sink output_file\n  pipeline = []\n  pipeline.push $values Array.from 'abcdef'\n  pipeline.push PS.$show()\n  pipeline.push sink\n  pull pipeline...\n  output_file.on 'finish', =>\n    T.ok CND.equals 'abcdef', FS.readFileSync output_path, { encoding: 'utf-8', }\n    T.end()\n\n#-----------------------------------------------------------------------------------------------------------\nTAP.test \"function as pull-stream source\", ( T ) ->\n  random = ( n ) =>\n    return ( end, callback ) =>\n      if end?\n        debug '40998', rpr callback\n        debug '40998', rpr end\n        return callback end\n      #only read n times, then stop.\n      n += -1\n      if n < 0\n        return callback true\n      callback null, Math.random()\n      return null\n  #.........................................................................................................\n  pipeline  = []\n  Ø         = ( x ) => pipeline.push x\n  Ø random 10\n  # Ø random 3\n  Ø PS.$collect()\n  Ø $ 'null', ( data, send ) ->\n    if data?\n      T.ok data.length is 10\n      debug data\n      send data\n    else\n      T.ok \"function works as pull-stream source\"\n      T.end()\n      send null\n  Ø PS.$show()\n  Ø PS.$drain()\n  #.........................................................................................................\n  PS.pull pipeline...\n  return null\n\n"
  ]
}