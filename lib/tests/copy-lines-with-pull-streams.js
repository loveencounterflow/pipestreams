// Generated by CoffeeScript 1.12.1
(function() {
  var $, $async, $split, $stringify, $utf8, CND, FS, O, PATH, PS, STPS, TAP, async_map, badge, debug, echo, format_float, format_integer, help, info, new_file_source, new_numeral, pull, rpr, through, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'BASIC-STREAM-BENCHMARKS-2/COPY-LINES-WITH-PULL-STREAM';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  new_numeral = require('numeral');

  format_float = function(x) {
    return (new_numeral(x)).format('0,0.000');
  };

  format_integer = function(x) {
    return (new_numeral(x)).format('0,0');
  };

  PATH = require('path');

  FS = require('fs');

  $split = require('pull-split');

  $stringify = require('pull-stringify');

  $utf8 = require('pull-utf8-decoder');

  new_file_source = require('pull-file');

  pull = require('pull-stream');


  /* NOTE these two are different: */

  through = require('pull-through');

  async_map = require('pull-stream/throughs/async-map');

  STPS = require('stream-to-pull-stream');

  O = {};

  O.pass_through_count = 0;

  O.implementation = 'pipestreams-map';

  TAP = require('tap');

  PS = require('../..');

  $ = PS.$, $async = PS.$async;

  TAP.test("performance regression", function(T) {
    var $as_line, $as_text, $count, $filter_comments, $filter_empty, $filter_incomplete, $my_utf8, $on_start, $on_stop, $pass, $select_fields, $show, $sink_example, $split_fields, $trim, XXX_through2, i, idx, input, input_path, item_count, output, output_path, pipeline, push, ref, t0, t1;
    input_path = PATH.resolve(__dirname, '../../test-data/Unicode-NamesList-tiny.txt');
    output_path = PATH.resolve(__dirname, '../../test-data/ids-copy.txt');
    input = PS.new_file_source(input_path);
    output = PS.new_file_sink(output_path);
    pipeline = [];
    push = pipeline.push.bind(pipeline);
    t0 = null;
    t1 = null;
    item_count = 0;
    $on_start = function() {
      return PS.map_start(function() {
        help(44402, "start");
        return t0 = Date.now();
      });
    };
    $on_stop = function() {
      return PS.map_stop(function() {
        var dts, dts_txt, ips, ips_txt, item_count_txt;
        t1 = Date.now();
        dts = (t1 - t0) / 1000;
        dts_txt = format_float(dts);
        item_count_txt = format_integer(item_count);
        ips = item_count / dts;
        ips_txt = format_float(ips);
        help(PATH.basename(__filename));
        help("pass-through count: " + O.pass_through_count);
        help(item_count_txt + " items; dts: " + dts_txt + ", ips: " + ips_txt);
        T.pass("looks good");
        return T.end();
      });
    };
    
  function XXX_map (read, map) {
    //return a readable function!
    return function (end, cb) {
      read(end, function (end, data) {
        debug(20323,rpr(data))
        cb(end, data != null ? map(data) : null)
      })
    }
  }
  ;
    
  function XXX_through (op, onEnd) {
    var a = false

    function once (abort) {
      if(a || !onEnd) return
      a = true
      onEnd(abort === true ? null : abort)
    }

    return function (read) {
      return function (end, cb) {
        if(end) once(end)
        return read(end, function (end, data) {
          if(!end) op && op(data)
          else once(end)
          cb(end, data)
        })
      }
    }
  }
  ;
    XXX_through2 = function(on_data, on_stop) {
      var collector, has_ended, once, send;
      has_ended = false;
      collector = [];
      once = function(abort) {
        if (has_ended) {
          return null;
        }
        if (on_stop == null) {
          return null;
        }
        has_ended = true;
        on_stop(abort === true ? null : abort);
        return null;
      };
      send = function(data) {
        return collector.push(data);
      };
      return function(read) {
        return function(end, handler) {
          if (end) {
            once(end);
          }
          return read(end, function(end, data) {
            var d, i, len;
            if (end) {
              once(end);
            } else {
              if (on_data != null) {
                on_data(data, send);
              }
            }
            if (collector.length > 0) {
              for (i = 0, len = collector.length; i < len; i++) {
                d = collector[i];
                handler(end, d);
              }
              collector.length = 0;
            } else {
              handler(end, null);
            }
          });
        };
      };
    };
    switch (O.implementation) {
      case 'pull-stream':
        $as_line = function() {
          return pull.map(function(line) {
            return line + '\n';
          });
        };
        $as_text = function() {
          return pull.map(function(fields) {
            return JSON.stringify(fields);
          });
        };
        $count = function() {
          return pull.map(function(line) {
            item_count += +1;
            return line;
          });
        };
        $select_fields = function() {
          return pull.map(function(fields) {
            var _, formula, glyph;
            _ = fields[0], glyph = fields[1], formula = fields[2];
            return [glyph, formula];
          });
        };
        $split_fields = function() {
          return pull.map(function(line) {
            return line.split('\t');
          });
        };
        $trim = function() {
          return pull.map(function(line) {
            return line.trim();
          });
        };
        $pass = function() {
          return pull.map(function(line) {
            return line;
          });
        };
        break;
      case 'pipestreams-remit':
        $as_line = function() {
          return $(function(line, send) {
            return send(line + '\n');
          });
        };
        $as_text = function() {
          return $(function(fields, send) {
            return send(JSON.stringify(fields));
          });
        };
        $count = function() {
          return $(function(line, send) {
            item_count += +1;
            return send(line);
          });
        };
        $select_fields = function() {
          return $(function(fields, send) {
            var _, formula, glyph;
            _ = fields[0], glyph = fields[1], formula = fields[2];
            return send([glyph, formula]);
          });
        };
        $split_fields = function() {
          return $(function(line, send) {
            return send(line.split('\t'));
          });
        };
        $trim = function() {
          return $(function(line, send) {
            return send(line.trim());
          });
        };
        $pass = function() {
          return $(function(line, send) {
            return send(line);
          });
        };
        break;
      case 'pipestreams-map':
        $as_line = function() {
          return PS.map(function(line) {
            return line + '\n';
          });
        };
        $as_text = function() {
          return PS.map(function(fields) {
            return JSON.stringify(fields);
          });
        };
        $count = function() {
          return PS.map(function(line) {
            item_count += +1;
            return line;
          });
        };
        $select_fields = function() {
          return PS.map(function(fields) {
            var _, formula, glyph;
            _ = fields[0], glyph = fields[1], formula = fields[2];
            return [glyph, formula];
          });
        };
        $split_fields = function() {
          return PS.map(function(line) {
            return line.split('\t');
          });
        };
        $trim = function() {
          return PS.map(function(line) {
            return line.trim();
          });
        };
        $pass = function() {
          return PS.map(function(line) {
            return line;
          });
        };
        $my_utf8 = function() {
          return PS.map(function(buffer) {
            debug(buffer);
            return buffer.toString('utf-8');
          });
        };
        $show = function() {
          return PS.map(function(data) {
            info(rpr(data));
            return data;
          });
        };
        $sink_example = function() {
          return function(read) {
            var next;
            next = function(error, data) {
              if (error) {
                return warn(error);
              }
              info('77775', data);
              read(null, next);
              return null;
            };
            read(null, next);
            return null;
          };
        };
    }
    $filter_empty = function() {
      return PS.filter(function(line) {
        return line.length > 0;
      });
    };
    $filter_comments = function() {
      return PS.filter(function(line) {
        return !line.startsWith('#');
      });
    };
    $filter_incomplete = function() {
      return PS.filter(function(fields) {
        var a, b;
        a = fields[0], b = fields[1];
        return (a != null) || (b != null);
      });
    };
    push(input);
    push($on_start());
    push($utf8());
    push($split());
    push($count());
    push($trim());
    push($filter_empty());
    push($filter_comments());
    push($split_fields());
    push($select_fields());
    push($filter_incomplete());
    push($as_text());
    push($as_line());
    for (idx = i = 1, ref = O.pass_through_count; i <= ref; idx = i += +1) {
      push($pass());
    }
    push($on_stop());
    push($sink_example());
    return pull.apply(null, pipeline);
  });

}).call(this);

//# sourceMappingURL=copy-lines-with-pull-streams.js.map
