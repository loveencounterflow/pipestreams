// Generated by CoffeeScript 2.3.1
(function() {
  'use strict';
  var $, $async, CND, FS, OS, PATH, PS, alert, badge, debug, defer, echo, help, info, is_empty, jr, log, new_filtered_bysink, rpr, test, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS/TESTS/WYE';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  FS = require('fs');

  OS = require('os');

  test = require('guy-test');

  //...........................................................................................................
  PS = require('../..');

  ({$, $async} = PS);

  //...........................................................................................................
  ({jr, is_empty} = CND);

  defer = setImmediate;

  // https://pull-stream.github.io/#pull-through

  // https://github.com/pull-stream/pull-cont
  // https://github.com/pull-stream/pull-defer
  // https://github.com/scrapjs/pull-imux
  // https://github.com/dominictarr/pull-flow (https://github.com/pull-stream/pull-stream/issues/4)

  //-----------------------------------------------------------------------------------------------------------
  this["$merge 1"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [[[["a", "b", "c"], [1, 2, 3, 4, 5, 6]], ["a", 1, "b", 2, "c", 3, 4, 5, 6], null]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var R, drainer, idx, j, max_idx, pipeline_1, pipeline_2, pipeline_3, ref, source_1, source_2, x;
          R = [];
          drainer = function() {
            return resolve(R);
          };
          source_1 = PS.new_push_source();
          source_2 = PS.new_push_source();
          //...................................................................................................
          pipeline_1 = [];
          pipeline_1.push(source_1);
          pipeline_1.push(PS.$watch(function(d) {
            return whisper('10191-2', d);
          }));
          //...................................................................................................
          pipeline_2 = [];
          pipeline_2.push(source_2);
          pipeline_2.push(PS.$watch(function(d) {
            return whisper('10191-3', d);
          }));
          //...................................................................................................
          pipeline_3 = [];
          pipeline_3.push(PS.$merge(PS.pull(...pipeline_1), PS.pull(...pipeline_2)));
          pipeline_3.push(PS.$watch(function(d) {
            return R.push(d);
          }));
          pipeline_3.push(PS.$watch(function(d) {
            return urge('10191-4', d);
          }));
          pipeline_3.push(PS.$drain(drainer));
          PS.pull(...pipeline_3);
          max_idx = (Math.max(probe[0].length, probe[1].length)) - 1;
          for (idx = j = 0, ref = max_idx; (0 <= ref ? j <= ref : j >= ref); idx = 0 <= ref ? ++j : --j) {
            if ((x = probe[0][idx]) != null) {
              source_1.send(x);
            }
            if ((x = probe[1][idx]) != null) {
              source_2.send(x);
            }
          }
          source_1.end();
          return source_2.end();
        });
      });
      done();
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  new_filtered_bysink = function(name, collector, filter) {
    var R;
    R = [];
    R.push(PS.$filter(filter));
    R.push(PS.$watch(function(d) {
      return collector.push(d);
    }));
    R.push(PS.$watch(function(d) {
      return whisper('10191', name, jr(d));
    }));
    R.push(PS.$drain());
    return PS.pull(...R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this["$wye 1"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [[[["a", "b", "c"], [1, 2, 3, 4, 5, 6]], [[1, 2, 3, 4, 5, 6], ["a", "b", "c"]], null]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var R, bysource, drainer, idx, j, mainstream, max_idx, numbers, ref, source_1, source_2, texts, x;
          numbers = [];
          texts = [];
          R = [numbers, texts];
          drainer = function() {
            return resolve(R);
          };
          source_1 = PS.new_push_source();
          source_2 = PS.new_push_source();
          //...................................................................................................
          bysource = [];
          bysource.push(source_2);
          bysource.push(PS.$watch(function(d) {
            return whisper('10191-5', 'bysource', jr(d));
          }));
          // bysource.push PS.$defer()
          bysource = PS.pull(...bysource);
          //...................................................................................................
          mainstream = [];
          mainstream.push(source_1);
          // mainstream.push PS.$defer()
          mainstream.push(PS.$wye(bysource));
          // mainstream.push PS.$watch ( d ) -> whisper '10191-6', 'confluence', jr d
          mainstream.push(PS.$tee(new_filtered_bysink('number', numbers, function(d) {
            return CND.isa_number(d);
          })));
          mainstream.push(PS.$tee(new_filtered_bysink('text', texts, function(d) {
            return CND.isa_text(d);
          })));
          mainstream.push(PS.$tee(new_filtered_bysink('other', null, function(d) {
            return (!CND.isa_number(d)) && (!CND.isa_text(d));
          })));
          mainstream.push(PS.$drain(drainer));
          PS.pull(...mainstream);
          //...................................................................................................
          max_idx = (Math.max(probe[0].length, probe[1].length)) - 1;
          for (idx = j = 0, ref = max_idx; (0 <= ref ? j <= ref : j >= ref); idx = 0 <= ref ? ++j : --j) {
            if ((x = probe[0][idx]) != null) {
              source_1.send(x);
            }
            if ((x = probe[1][idx]) != null) {
              source_2.send(x);
            }
          }
          source_1.end();
          return source_2.end();
        });
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["$wye 2"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [[[true, true, ["a", "b", "c"], [1, 2, 3, 4, 5, 6]], ["a", 1, "b", 2, "c", 3, 4, 5, 6], null], [[false, true, ["a", "b", "c"], [1, 2, 3, 4, 5, 6]], ["a", 1, "b", 2, "c", 3, 4, 5, 6], null], [[false, false, ["a", "b", "c"], [1, 2, 3, 4, 5, 6]], ["a", 1, "b", 2, "c", 3, 4, 5, 6], null], [[true, false, ["a", "b", "c"], [1, 2, 3, 4, 5, 6]], ["a", 1, "b", 2, "c", 3, 4, 5, 6], null]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      matcher = matcher.sort();
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var R, bysource, bystream, bystream_values, defer_bystream, defer_mainstream, drainer, idx, j, mainsource, mainstream, mainstream_values, max_idx, ref, x;
          [defer_mainstream, defer_bystream, mainstream_values, bystream_values] = probe;
          R = [];
          drainer = function() {
            R = R.sort();
            return resolve(R);
          };
          mainsource = PS.new_push_source();
          bysource = PS.new_push_source();
          //...................................................................................................
          bystream = [];
          bystream.push(bysource);
          bystream.push(PS.$watch(function(d) {
            return whisper('10192-1', 'bysource', jr(d));
          }));
          if (defer_bystream) {
            bystream.push(PS.$defer());
          }
          bystream = PS.pull(...bystream);
          //...................................................................................................
          mainstream = [];
          mainstream.push(mainsource);
          mainstream.push($({
            last: 'last'
          }, function(d, send) {
            urge('10192-2', 'mainstream', d);
            if (d !== 'last') {
              return send(d);
            }
          }));
          if (defer_mainstream) {
            mainstream.push(PS.$defer());
          }
          mainstream.push(PS.$watch(function(d) {
            return whisper('10192-3', 'mainstream', jr(d));
          }));
          mainstream.push(PS.$wye(bystream));
          mainstream.push(PS.$watch(function(d) {
            return R.push(d);
          }));
          mainstream.push(PS.$watch(function(d) {
            return urge(CND.white('10192-4', 'confluence', jr(d)));
          }));
          mainstream.push(PS.$drain(drainer));
          PS.pull(...mainstream);
          max_idx = (Math.max(mainstream_values.length, bystream_values.length)) - 1;
          for (idx = j = 0, ref = max_idx; (0 <= ref ? j <= ref : j >= ref); idx = 0 <= ref ? ++j : --j) {
            if ((x = mainstream_values[idx]) != null) {
              mainsource.send(x);
            }
            if ((x = bystream_values[idx]) != null) {
              bysource.send(x);
            }
          }
          mainsource.end();
          bysource.end();
          return null;
        });
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["divert"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        [10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20],
        {
          "odd_numbers": [11,
        13,
        15,
        17,
        19],
          "all_numbers": [10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20]
        },
        null
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      //.......................................................................................................
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var R, all_numbers, byline, bystream, is_odd, mainline, odd_numbers;
          is_odd = function(d) {
            return (d % 2) !== 0;
          };
          odd_numbers = [];
          all_numbers = [];
          R = {odd_numbers, all_numbers};
          //.....................................................................................................
          byline = [];
          mainline = [];
          //.....................................................................................................
          byline.push(PS.$show({
            title: 'bystream'
          }));
          byline.push(PS.$watch(function(d) {
            return odd_numbers.push(d);
          }));
          byline.push(PS.$drain());
          bystream = PS.pull(...byline);
          //.....................................................................................................
          mainline.push(PS.new_value_source(probe));
          mainline.push(PS.$tee(is_odd, bystream));
          mainline.push(PS.$show({
            title: 'mainstream'
          }));
          mainline.push(PS.$watch(function(d) {
            return all_numbers.push(d);
          }));
          mainline.push(PS.$drain(function() {
            help('ok');
            return resolve(R);
          }));
          PS.pull(...mainline);
          //.....................................................................................................
          return null;
        });
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["bifurcate"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        [10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20],
        {
          "odd_numbers": [11,
        13,
        15,
        17,
        19],
          "even_numbers": [10,
        12,
        14,
        16,
        18,
        20]
        },
        null
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      //.......................................................................................................
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var R, byline, bystream, even_numbers, is_even, mainline, odd_numbers;
          is_even = function(d) {
            return (d % 2) === 0;
          };
          odd_numbers = [];
          even_numbers = [];
          R = {odd_numbers, even_numbers};
          //.....................................................................................................
          byline = [];
          mainline = [];
          //.....................................................................................................
          byline.push(PS.$show({
            title: 'bystream'
          }));
          byline.push(PS.$watch(function(d) {
            return even_numbers.push(d);
          }));
          byline.push(PS.$drain());
          bystream = PS.pull(...byline);
          //.....................................................................................................
          mainline.push(PS.new_value_source(probe));
          mainline.push(PS.$bifurcate(is_even, bystream));
          mainline.push(PS.$show({
            title: 'mainstream'
          }));
          mainline.push(PS.$watch(function(d) {
            return odd_numbers.push(d);
          }));
          mainline.push(PS.$drain(function() {
            help('ok');
            return resolve(R);
          }));
          PS.pull(...mainline);
          //.....................................................................................................
          return null;
        });
      });
    }
    //.........................................................................................................
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["wye from asnyc random sources"] = async function(T, done) {
    /* A mainstream and a bystream are created from lists of values using
    `PS.new_random_async_value_source()`. Values from both streams are marked up for their respective source.
    After being funnelled together using `PS.$wye()`, the result is a POD whose keys are the source names
    and whose values are lists of the values in the order they were seen. The expected result is that the
    ordering of each stream is preserved, no values get lost, and that relative ordering of values in the
    mainstream and the bystream is arbitrary. */
    var R, error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        [[3,
        4,
        5,
        6,
        7,
        8],
        ["just",
        "a",
        "few",
        "words"]],
        {
          "bystream": [3,
        4,
        5,
        6,
        7,
        8],
          "mainstream": ["just",
        "a",
        "few",
        "words"]
        },
        null
      ],
      [
        [[3,
        4],
        [9,
        10,
        11,
        true]],
        {
          "bystream": [3,
        4],
          "mainstream": [9,
        10,
        11,
        true]
        },
        null
      ],
      [
        [
          [
            3,
            4,
            {
              "foo": "bar"
            }
          ],
          [false,
          9,
          10,
          11,
          true]
        ],
        {
          "bystream": [
            3,
            4,
            {
              "foo": "bar"
            }
          ],
          "mainstream": [false,
        9,
        10,
        11,
        true]
        },
        null
      ]
    ];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      R = null;
      //.......................................................................................................
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var byline, mainline;
          byline = [];
          byline.push(PS.new_random_async_value_source(0.1, probe[0]));
          byline.push($(function(d, send) {
            return send(['bystream', d]);
          }));
          // byline.push PS.$watch ( d ) -> whisper 'bystream', jr d
          //.....................................................................................................
          mainline = [];
          mainline.push(PS.new_random_async_value_source(probe[1]));
          mainline.push($(function(d, send) {
            return send(['mainstream', d]);
          }));
          mainline.push(PS.$wye(PS.pull(...byline)));
          mainline.push(PS.$collect());
          mainline.push(PS.$watch(function(d) {
            var j, len1, results, x;
            R = {
              bystream: [],
              mainstream: []
            };
            results = [];
            for (j = 0, len1 = d.length; j < len1; j++) {
              x = d[j];
              results.push(R[x[0]].push(x[1]));
            }
            return results;
          }));
          mainline.push(PS.$drain(function() {
            help('ok');
            return resolve(R);
          }));
          PS.pull(...mainline);
          //.....................................................................................................
          return null;
        });
      });
    }
    //.........................................................................................................
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["$wye 3"] = async function(T, done) {
    var end_sym, error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [
      [
        {
          "start_value": 0.5,
          "delta": 0.01,
          "min": 0.3233333333333333,
          "max": 0.3433333333333333
        },
        [0.5,
        0.25,
        0.375,
        0.3125,
        0.34375,
        0.328125],
        null
      ]
    ];
    end_sym = Symbol.for('end');
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      probe.min = 1 / 3 - probe.delta;
      probe.max = 1 / 3 + probe.delta;
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var R, bysource, bystream, drainer, mainsource, mainstream;
          R = [];
          drainer = function() {
            debug('10191-1', "mainstream ended");
            return resolve(R);
          };
          mainsource = PS.new_push_source();
          bysource = PS.new_push_source();
          //...................................................................................................
          bystream = [];
          bystream.push(bysource);
          bystream.push($({
            last: end_sym
          }, function(d, send) {
            if (d === end_sym) {
              debug('22092', "bystream ended");
            } else {
              send(d);
            }
            return null;
          }));
          bystream.push(PS.$watch(function(d) {
            return whisper('10191-1', 'bysource', jr(d));
          }));
          bystream = PS.pull(...bystream);
          //...................................................................................................
          mainstream = [];
          mainstream.push(mainsource);
          mainstream.push(PS.$wye(bystream));
          mainstream.push(PS.$async(function(d, send, done) {
            send(d);
            if ((probe.min <= d && d <= probe.max)) {
              defer(function() {
                send(end_sym);
                bysource.send(end_sym);
                return done();
              });
            } else {
              defer(function() {
                bysource.send((1 - d) / 2);
                return done();
              });
            }
            return null;
          }));
          mainstream.push(PS.$defer());
          mainstream.push(PS.$watch(function(d) {
            return urge(CND.white('10191-4', 'confluence', jr(d)));
          }));
          mainstream.push(PS.$watch(function(d) {
            return R.push(d);
          }));
          mainstream.push(PS.$drain(drainer));
          PS.pull(...mainstream);
          mainsource.send(probe.start_value);
          return null;
        });
      });
    }
    done();
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    // test @
    // test @[ "$merge 1" ]
    // test @[ "$wye 1" ]
    test(this["$wye 2"]);
  }

  // test @[ "$wye 3" ]
// test @[ "divert" ]
// test @[ "bifurcate" ]
// test @[ "wye from asnyc random sources" ]

}).call(this);

//# sourceMappingURL=wyes.test.js.map
