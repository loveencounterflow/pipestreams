// Generated by CoffeeScript 2.3.1
(function() {
  //###########################################################################################################
  var $, $async, CND, FS, OS, PATH, PS, alert, badge, debug, defer, echo, help, info, is_empty, jr, log, provide_$wye, rpr, test, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS/TESTS/WYE';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  FS = require('fs');

  OS = require('os');

  test = require('guy-test');

  //...........................................................................................................
  PS = require('../..');

  ({$, $async} = PS);

  //...........................................................................................................
  ({jr, is_empty} = CND);

  defer = setImmediate;

  // https://pull-stream.github.io/#pull-through

  // https://github.com/pull-stream/pull-cont
  // https://github.com/pull-stream/pull-defer
  // https://github.com/scrapjs/pull-imux
  // https://github.com/dominictarr/pull-flow (https://github.com/pull-stream/pull-stream/issues/4)

  //-----------------------------------------------------------------------------------------------------------
  provide_$wye = function() {
    var mux;
    mux = require('pull-mux');
    //-----------------------------------------------------------------------------------------------------------
    this./* https://github.com/nichoth/pull-mux */$merge = function(...sources) {
      var $_demux, $_mux, pipeline;
      //.........................................................................................................
      $_mux = (...sources) => {
        var R, i, idx, len, source;
        R = {};
        for (idx = i = 0, len = sources.length; i < len; idx = ++i) {
          source = sources[idx];
          R[idx] = source;
        }
        return mux(R);
      };
      //.........................................................................................................
      $_demux = () => {
        return this.$map(function([k, v]) {
          return v;
        });
      };
      //.........................................................................................................
      pipeline = [];
      pipeline.push($_mux(...sources));
      pipeline.push($_demux());
      return this.pull(...pipeline);
    };
    //-----------------------------------------------------------------------------------------------------------
    return this.$wye = function(bysource) {
      var R, buffer, bystream, bystream_ended, bystream_started, done, flush, mainstream, mainstream_ended, send, stack;
      mainstream_ended = false;
      bystream_started = false;
      bystream_ended = false;
      send = null;
      done = null;
      buffer = [];
      stack = (x) => {
        return buffer.unshift(x);
      };
      flush = () => {
        var results;
        results = [];
        while (!is_empty(buffer)) {
          results.push(send(buffer.pop()));
        }
        return results;
      };
      //.........................................................................................................
      bystream = [];
      bystream.push(bysource);
      bystream.push(this.$('null', (d, _send) => {
        if (d != null) {
          /* When `done` is defined, mainstream has ended, but `done` has not been called, meaning we can
          send directly (but avoid calling `done` yet); otherwise, we buffer the data: */
          if (done != null) {
            send(d);
          } else {
            stack(d);
          }
        } else {
          bystream_ended = true;
          if (done != null) {
            flush();
            done();
          }
        }
        return null;
      }));
      bystream.push(this.$drain());
      //.........................................................................................................
      mainstream = [];
      mainstream.push(this.$async('null', (d, _send, _done) => {
        send = _send;
        done = _done;
        //.......................................................................................................
        if (!bystream_started) {
          bystream_started = true;
          this.pull(...bystream);
        }
        //.......................................................................................................
        if (d != null) {
          /* In case there's mainstream data, flush out any bystream data first, then send d, call `done` and
          un-define it: */
          flush();
          send(d);
          done();
          done = null;
        } else {
          /* In case mainstream data is `null`, mainstream has terminated. If bystream has been terminated
          as well, call `done` and un-define it: */
          flush();
          if (bystream_ended) {
            done();
            done = null;
          }
        }
        //.......................................................................................................
        return null;
      }));
      // mainstream.push @$tee ( d ) => urge '***', d
      //.........................................................................................................
      R = this.pull(...mainstream);
      return R;
    };
  };

  provide_$wye.apply(PS);

  //-----------------------------------------------------------------------------------------------------------
  this["$merge 1"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [[[["a", "b", "c"], [1, 2, 3, 4, 5, 6]], ["a", 1, "b", 2, "c", 3, 4, 5, 6], null]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var R, drainer, idx, j, max_idx, pipeline_1, pipeline_2, pipeline_3, ref, source_1, source_2, x;
          R = [];
          drainer = function() {
            return resolve(R);
          };
          source_1 = PS.new_push_source();
          source_2 = PS.new_push_source();
          //...................................................................................................
          pipeline_1 = [];
          pipeline_1.push(source_1);
          pipeline_1.push(PS.$watch(function(d) {
            return whisper('10191-2', d);
          }));
          //...................................................................................................
          pipeline_2 = [];
          pipeline_2.push(source_2);
          pipeline_2.push(PS.$watch(function(d) {
            return whisper('10191-3', d);
          }));
          //...................................................................................................
          pipeline_3 = [];
          pipeline_3.push(PS.$merge(PS.pull(...pipeline_1), PS.pull(...pipeline_2)));
          pipeline_3.push(PS.$watch(function(d) {
            return R.push(d);
          }));
          pipeline_3.push(PS.$watch(function(d) {
            return urge('10191-4', d);
          }));
          pipeline_3.push(PS.$drain(drainer));
          PS.pull(...pipeline_3);
          max_idx = (Math.max(probe[0].length, probe[1].length)) - 1;
          for (idx = j = 0, ref = max_idx; (0 <= ref ? j <= ref : j >= ref); idx = 0 <= ref ? ++j : --j) {
            if ((x = probe[0][idx]) != null) {
              source_1.push(x);
            }
            if ((x = probe[1][idx]) != null) {
              source_2.push(x);
            }
          }
          source_1.end();
          return source_2.end();
        });
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["$wye 1"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [[[["a", "b", "c"], [1, 2, 3, 4, 5, 6]], ["a", 1, "b", 2, "c", 3, 4, 5, 6], null]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var R, bysource, drainer, idx, j, mainstream, max_idx, ref, source_1, source_2, x;
          R = [];
          drainer = function() {
            return resolve(R);
          };
          source_1 = PS.new_push_source();
          source_2 = PS.new_push_source();
          //...................................................................................................
          bysource = [];
          bysource.push(source_2);
          bysource.push(PS.$watch(function(d) {
            return whisper('10191-5', 'bysource', jr(d));
          }));
          // bysource.push PS.$defer()
          bysource = PS.pull(...bysource);
          //...................................................................................................
          mainstream = [];
          mainstream.push(source_1);
          mainstream.push(PS.$watch(function(d) {
            return whisper('10191-6', 'mainstream', jr(d));
          }));
          mainstream.push(PS.$wye(bysource));
          mainstream.push(PS.$watch(function(d) {
            return R.push(d);
          }));
          mainstream.push(PS.$watch(function(d) {
            return urge(CND.white('10191-7', 'confluence', jr(d)));
          }));
          mainstream.push(PS.$drain(drainer));
          PS.pull(...mainstream);
          max_idx = (Math.max(probe[0].length, probe[1].length)) - 1;
          for (idx = j = 0, ref = max_idx; (0 <= ref ? j <= ref : j >= ref); idx = 0 <= ref ? ++j : --j) {
            if ((x = probe[0][idx]) != null) {
              source_1.push(x);
            }
            if ((x = probe[1][idx]) != null) {
              source_2.push(x);
            }
          }
          source_1.end();
          return source_2.end();
        });
      });
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["$wye 2"] = async function(T, done) {
    var error, i, len, matcher, probe, probes_and_matchers;
    probes_and_matchers = [[[true, true, ["a", "b", "c"], [1, 2, 3, 4, 5, 6]], ["a", 1, "b", 2, "c", 3, 4, 5, 6], null], [[false, true, ["a", "b", "c"], [1, 2, 3, 4, 5, 6]], ["a", 1, "b", 2, "c", 3, 4, 5, 6], null], [[false, false, ["a", "b", "c"], [1, 2, 3, 4, 5, 6]], ["a", 1, "b", 2, "c", 3, 4, 5, 6], null], [[true, false, ["a", "b", "c"], [1, 2, 3, 4, 5, 6]], ["a", 1, "b", 2, "c", 3, 4, 5, 6], null]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      matcher = matcher.sort();
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var R, bysource, bystream, bystream_values, defer_bystream, defer_mainstream, drainer, idx, j, mainsource, mainstream, mainstream_values, max_idx, ref, x;
          [defer_mainstream, defer_bystream, mainstream_values, bystream_values] = probe;
          R = [];
          drainer = function() {
            R = R.sort();
            return resolve(R);
          };
          mainsource = PS.new_push_source();
          bysource = PS.new_push_source();
          //...................................................................................................
          bystream = [];
          bystream.push(bysource);
          bystream.push(PS.$watch(function(d) {
            return whisper('10191-5', 'bysource', jr(d));
          }));
          if (defer_bystream) {
            bystream.push(PS.$defer());
          }
          bystream = PS.pull(...bystream);
          //...................................................................................................
          mainstream = [];
          mainstream.push(mainsource);
          if (defer_mainstream) {
            mainstream.push(PS.$defer());
          }
          mainstream.push(PS.$watch(function(d) {
            return whisper('10191-6', 'mainstream', jr(d));
          }));
          mainstream.push(PS.$wye(bystream));
          mainstream.push(PS.$watch(function(d) {
            return R.push(d);
          }));
          mainstream.push(PS.$watch(function(d) {
            return urge(CND.white('10191-7', 'confluence', jr(d)));
          }));
          mainstream.push(PS.$drain(drainer));
          PS.pull(...mainstream);
          max_idx = (Math.max(mainstream_values.length, bystream_values.length)) - 1;
          for (idx = j = 0, ref = max_idx; (0 <= ref ? j <= ref : j >= ref); idx = 0 <= ref ? ++j : --j) {
            if ((x = mainstream_values[idx]) != null) {
              mainsource.push(x);
            }
            if ((x = bystream_values[idx]) != null) {
              bysource.push(x);
            }
          }
          mainsource.end();
          bysource.end();
          return null;
        });
      });
    }
    done();
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    test(this);
  }

  // test @[ "$wye 1" ]
// test @[ "$wye 2" ]

}).call(this);

//# sourceMappingURL=wyes.test.js.map
