// Generated by CoffeeScript 2.0.0-beta3
(function() {
  var $, $async, CND, FS, OS, PATH, PS, TAP, alert, badge, debug, echo, help, info, jr, log, rpr, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS/TESTS/TEE';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  PATH = require('path');

  FS = require('fs');

  OS = require('os');

  TAP = require('tap');

  PS = require('../..');

  ({$, $async} = PS);

  jr = JSON.stringify;

  TAP.test("spawn 1", function(T) {
    var command, on_error, on_stop, pipeline, source;
    on_error = function(error) {
      return warn('20191', error.message);
    };
    command = 'ls -AlF';
    source = PS.spawn(command, {
      on_error,
      cwd: '/tmp'
    });
    on_stop = PS.new_event_collector('stop', function() {
      return T.end();
    });
    pipeline = [];
    pipeline.push(source);
    pipeline.push(PS.$watch(function(data) {
      return whisper(rpr(data));
    }));
    pipeline.push(PS.$split());
    pipeline.push(PS.$collect());
    pipeline.push(PS.$watch(function(lines) {
      return help(lines);
    }));
    pipeline.push(on_stop.add(PS.$drain()));
    PS.pull(...pipeline);
    return null;
  });

  TAP.test("spawn 2", function(T) {
    var fn, i, len, next, probe_and_matcher, probes_and_matchers, tasks;
    probes_and_matchers = [["xxx ; echo \"helo\" && exit 1", "CDDX", 1, null, "helo", "/bin/sh: xxx: command not found"], ["xxx ; echo \"helo\" && exit 0", "CDDX", 0, null, "helo", "/bin/sh: xxx: command not found"], ["xxx ; echo \"helo\"", "CDDX", 0, null, "helo", "/bin/sh: xxx: command not found"], ["xxx && echo \"helo\"", "CDX", 127, null, "", "/bin/sh: xxx: command not found"], ["exit 111", "CX", 111, null, "", ""], ["ls && echo_to_stderr() { cat <<< \"$@\" 1>&2; }; echo_to_stderr what", "CDDDDDDDDDDX", 0, null, "coverage\nlib\nLICENSE\nnode_modules\npackage.json\npackage-lock.json\nREADME.md\nsrc\ntest-data", "what"], ["( >&2 echo \"error\" )", "CDX", 0, null, "", "error"], ["echo_to_stderr() { cat <<< \"$@\" 1>&2; }; echo_to_stderr what; echo else; sleep 1; kill -9 $$", "CDDX", 137, "SIGKILL", "else", "what"], ["kill -2 $$", "CX", 130, "SIGINT", "", ""], ["exit 130", "CX", 130, null, "", ""], ["bonkers", "CDX", 127, null, "", "/bin/sh: bonkers: command not found"], ["bonkers 2>&1; exit 0", "CDX", 0, null, "/bin/sh: bonkers: command not found", ""], ["bonkers; echo \"success!\"; exit 0", "CDDX", 0, null, "success!", "/bin/sh: bonkers: command not found"], ["bonkers; echo \"success!\"; kill -27 $$", "CDDX", 155, "SIGPROF", "success!", "/bin/sh: bonkers: command not found"]];
    tasks = [];
    next = function() {
      tasks.shift();
      if (tasks.length === 0) {
        return T.end();
      }
      return tasks[0]();
    };
    fn = function(probe_and_matcher) {
      var code_matcher, command, err_matcher, out_matcher, shape_matcher, signal_matcher;
      [command, shape_matcher, code_matcher, signal_matcher, out_matcher, err_matcher] = probe_and_matcher;
      return tasks.push(function() {
        var code, command_ok, err, on_stop, out, pipeline, shape, signal, source;
        shape = [];
        out = [];
        err = [];
        code = void 0;
        signal = void 0;
        command_ok = false;
        on_stop = PS.new_event_collector('stop', function() {
          shape = shape.join('');
          out = out.join('\n');
          err = err.join('\n');
          T.ok(command_ok);
          T.equal(shape, shape_matcher, "shape,  shape_matcher");
          T.equal(code, code_matcher, "code,   code_matcher");
          T.equal(signal, signal_matcher, "signal, signal_matcher");
          T.equal(out, out_matcher, "out,    out_matcher");
          T.equal(err, err_matcher, "err,    err_matcher");
          return next();
        });
        source = PS.spawn(command);
        pipeline = [];
        pipeline.push(source);
        pipeline.push(PS.$watch(function([key, value]) {
          switch (key) {
            case 'command':
              return shape.push('C');
            case 'stdout':
            case 'stderr':
              return shape.push('D');
            case 'exit':
              return shape.push('X');
            default:
              return shape.push('?');
          }
        }));
        pipeline.push(PS.$watch(function([key, value]) {
          if (key === 'command' && value === command) {
            return command_ok = true;
          }
        }));
        pipeline.push(PS.$watch(function([key, value]) {
          switch (key) {
            case 'stdout':
              return out.push(value);
            case 'stderr':
              return err.push(value);
            case 'exit':
              return {code, signal} = value;
          }
        }));
        pipeline.push(PS.$collect());
        pipeline.push(on_stop.add(PS.$drain()));
        return PS.pull(...pipeline);
      });
    };
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      probe_and_matcher = probes_and_matchers[i];
      fn(probe_and_matcher);
    }
    tasks[0]();
    return null;
  });

  TAP.test("spawn 3", function(T) {
    var fn, i, len, next, probe_and_matcher, probes_and_matchers, tasks;
    probes_and_matchers = [
      [
        "bonkers; echo \"success!\"; kill -27 $$", "CDX", {
          "code": 155,
          "signal": "SIGPROF",
          "error": "/bin/sh: bonkers: command not found"
        }, "success!", ""
      ], [
        "echo \"success!\"; kill -27 $$", "CDX", {
          "code": 155,
          "signal": "SIGPROF",
          "error": null
        }, "success!", ""
      ], [
        "echo \"success!\"; exit 1", "CDX", {
          "code": 1,
          "signal": null,
          "error": null
        }, "success!", ""
      ], [
        "echo \"success!\"; exit 0", "CDX", {
          "code": 0,
          "signal": null,
          "error": null
        }, "success!", ""
      ], [
        "1>&2 echo 'problem!'", "CX", {
          "code": 0,
          "signal": null,
          "error": "problem!"
        }, "", ""
      ]
    ];
    tasks = [];
    next = function() {
      tasks.shift();
      if (tasks.length === 0) {
        return T.end();
      }
      return tasks[0]();
    };
    fn = function(probe_and_matcher) {
      var command, err_matcher, exit_matcher, out_matcher, shape_matcher;
      [command, shape_matcher, exit_matcher, out_matcher, err_matcher] = probe_and_matcher;
      return tasks.push(function() {
        var err, exit, on_stop, out, pipeline, shape, source;
        shape = [];
        out = [];
        err = [];
        exit = void 0;
        on_stop = PS.new_event_collector('stop', function() {
          shape = shape.join('');
          out = out.join('\n');
          err = err.join('\n');
          T.equal(shape, shape_matcher, "shape,  shape_matcher");
          T.ok(CND.equals(exit, exit_matcher), "exit,   exit_matcher");
          T.equal(out, out_matcher, "out,    out_matcher");
          T.equal(err, err_matcher, "err,    err_matcher");
          return next();
        });
        source = PS.spawn(command, {
          error_to_exit: true
        });
        pipeline = [];
        pipeline.push(source);
        pipeline.push(PS.$watch(function([key, value]) {
          switch (key) {
            case 'command':
              return shape.push('C');
            case 'stdout':
            case 'stderr':
              return shape.push('D');
            case 'exit':
              return shape.push('X');
            default:
              return shape.push('?');
          }
        }));
        pipeline.push(PS.$watch(function([key, value]) {
          switch (key) {
            case 'stdout':
              return out.push(value);
            case 'stderr':
              return err.push(value);
            case 'exit':
              return exit = value;
          }
        }));
        pipeline.push(on_stop.add(PS.$drain()));
        return PS.pull(...pipeline);
      });
    };
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      probe_and_matcher = probes_and_matchers[i];
      fn(probe_and_matcher);
    }
    tasks[0]();
    return null;
  });

}).call(this);

//# sourceMappingURL=spawn.js.map
