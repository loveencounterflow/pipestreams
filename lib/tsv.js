// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var CND, badge, debug, echo, help, info, rpr, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS/TSV';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //-----------------------------------------------------------------------------------------------------------
  this.$name_fields = function(names) {
    var type;
    if ((type = CND.type_of(names)) !== 'list') {
      throw new Error(`µ27276 expected a list, got a ${type}`);
    }
    return this._map_errors((fields) => {
      var R, i, idx, len, name, value;
      if ((type = CND.type_of(fields)) !== 'list') {
        throw new Error(`µ27597 expected a list, got a ${type}`);
      }
      R = {};
      for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
        value = fields[idx];
        name = names[idx] != null ? names[idx] : names[idx] = `field_${idx}`;
        R[name] = value;
      }
      return R;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$split_on_tabs = function(settings) {
    return this.$((line, send) => {
      var type;
      if ((type = CND.type_of(line)) !== 'text') {
        `µ27918 expected a text, got a ${type}`;
      }
      return send(line.split(/\t/));
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$split_on_whitespace = function(field_count = null) {
    //.........................................................................................................
    /* If user requested null or zero fields, we can just split the line: */
    if ((field_count == null) || (field_count === 0)) {
      return this.$((line, send) => {
        return send(line.split(/\s+/));
      });
    }
    //.........................................................................................................
    /* If user requested one field, then the entire line is the field: */
    if (field_count === 1) {
      return this.$((line, send) => {
        return send([line]);
      });
    }
    //.........................................................................................................
    /* TAINT validate field_count is integer */
    /* TAINT validate field_count is non-negative */
    return this.$((line, send) => {
      var fields, fld, idx, pairs, parts, spc, type;
      if ((type = CND.type_of(line)) !== 'text') {
        `µ28239 expected a text, got a ${type}`;
      }
      fields = [];
      parts = line.split(/(\s+)/);
      pairs = (function() {
        var i, ref, ref1, results;
        results = [];
        for (idx = i = 0, ref = parts.length; i < ref; idx = i += +2) {
          results.push([parts[idx], (ref1 = parts[idx + 1]) != null ? ref1 : '']);
        }
        return results;
      })();
      while (true) {
        if (pairs.length <= 0) {
          //.......................................................................................................
          /* Shift-push line contents from `pairs` into `fields` until exhausted or saturated: */
          break;
        }
        if (fields.length >= field_count - 1) {
          break;
        }
        fields.push(pairs.shift()[0]);
      }
      //.......................................................................................................
      /* Concat remaining parts and add as one more field: */
      if (pairs.length > 0) {
        fields.push((((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = pairs.length; i < len; i++) {
            [fld, spc] = pairs[i];
            results.push(fld + spc);
          }
          return results;
        })()).join('')).trim());
      }
      while (fields.length < field_count) {
        //.......................................................................................................
        /* Pad missing fields with `null`: */
        /* TAINT allow to configure padding value */
        fields.push(null);
      }
      //.......................................................................................................
      return send(fields);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$trim_fields = function() {
    return this.$watch((fields) => {
      var field, i, idx, len, type;
      if ((type = CND.type_of(fields)) !== 'list') {
        throw new Error(`µ28560 expected a list, got a ${type}`);
      }
      for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
        field = fields[idx];
        fields[idx] = field.trim();
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$split_tsv = function() {
    var R;
    R = [];
    R.push(this.$split());
    // R.push @$trim()
    R.push(this.$skip_blank());
    /* TAINT use named method; allow to configure comment marker */
    R.push(this.$filter(function(line) {
      return !line.startsWith('#');
    }));
    R.push(this.$split_on_tabs());
    R.push(this.$trim_fields());
    return this.pull(...R);
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use `settings` for extensibility */
  this.$split_wsv = function(field_count = 0) {
    var R;
    R = [];
    R.push(this.$split());
    // R.push @$trim()
    R.push(this.$skip_blank());
    /* TAINT use named method; allow to configure comment marker */
    R.push(this.$filter(function(line) {
      return !line.startsWith('#');
    }));
    R.push(this.$split_on_whitespace(field_count));
    return this.pull(...R);
  };

}).call(this);

//# sourceMappingURL=tsv.js.map
